<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0076)http://www.partow.net/programming/strtk/index.html#Introduction%20To%20StrTk -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <meta name="Author" content="Arash Partow">
  <meta name="title" content="C++ String Library (StrTk)">
  <meta name="keywords" content="strtk, arash partow, string, tokenize, c++, c++ string library, parse, parser, std::string, token, lex, base64, match, search, filter, process, algorithm, hash, grid, cast, library, string library, process, strtok, string algorithm, string tokenizer, stringtokenizer, combinatorics, randomizations, csv, dsv, prefix, bloom, bloom filter, renaissance technologies, rentec">
  <meta name="description" content="C++ String Toolkit Library (StrTk)">
  <meta name="category" content="Computers Internet">
  <meta name="robots" content="all">
  
  <title>.:: C++ String Toolkit Library (StrTk) - By Arash Partow ::.</title>
  <link rel="shortcut icon" href="http://www.partow.net/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/style.css" type="text/css">
</head>

<body><script type="text/javascript" language="JavaScript1.2" src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/unframepage.js.&#19979;&#36733;"></script><script type="text/javascript" src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/saved_resource"></script>
<br>

<script type="text/javascript" src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/saved_resource(1)"></script>

<div align="center">

<table border="0" cellspacing="0" cellpadding="0" width="980">
  <tbody>
    <tr>
      <td colspan="3" class="pos1" height="55" valign="middle">
        <div class="topbox">
        <h2 align="left">C++ String Toolkit Library</h2>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <table width="100%" border="0" cellpadding="0" cellspacing="0" class="topnav">
          <tbody>
            <tr>
              <td align="left" class="head">&nbsp;www.partow.net</td>
              <td align="right">

               <a href="http://www.partow.net/index.html" class="topmenu" title="www.partow.net">&nbsp;.: Home :.&nbsp; </a>
               <a href="http://www.partow.net/links.html" class="topmenu" title="Links">&nbsp;.: Links :.&nbsp; </a>
               <a href="http://www.partow.net/search.html" class="topmenu" title="Search">&nbsp;.: Search :.&nbsp; </a>
               <a href="http://www.partow.net/contact.html" class="topmenuf" title="Contact Arash Partow">&nbsp;.: Contact :.&nbsp;</a>
              </td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td>
        <table width="100%" border="0" cellpadding="0" cellspacing="0">
          <tbody>
            <tr>
              <td valign="top" width="150"><br>


                <div>

                 <div class="headbox">Main Menu</div>
                  <a class="leftmenu" href="http://www.partow.net/about/index.html" title="About Arash Partow">About        </a>
                  <a class="leftmenu" href="http://www.partow.net/programming/index.html" title="Programming">Programming  </a>
                  <a class="leftmenu" href="http://www.partow.net/projects/index.html" title="Projects">Projects     </a>
                  <a class="leftmenu" href="http://www.partow.net/miscellaneous/index.html" title="Miscellaneous">Miscellaneous</a>
                  <br>

                 <div class="headbox">Topics</div>
                  <a class="leftmenu" href="http://www.partow.net/programming/strtk/index.html" title="String Toolkit Library">String Toolkit Library</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/exprtk/index.html" title="C++ Mathematical Expression Library">C++ Mathematical Expression Library</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/templatecallback/index.html" title="Callbacks In C++">Callbacks In C++</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/hashfunctions/index.html" title="General Purpose Hash Function Algorithms">General Purpose Hash Function Algorithms</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/bitmap/index.html" title="C++ Bitmap Library">C++ Bitmap Library</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/tcpproxy/index.html" title="C++ TCP Proxy Server">C++ TCP Proxy Server</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/bloomfilter/index.html" title="C++ Bloom Filter Library">C++ Bloom Filter Library</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/dsvfilter/index.html" title="C++ DSV Filter Library">C++ DSV Filter Library</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/vxt/index.html" title="C++ Vector Expression Template Library">C++ Vector Expression Template Library</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/lexertk/index.html" title="C++ Lexer Library">C++ Lexer Library</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/datetime/index.html" title="C++ Date And Time Parsing Utilities">C++ Date And Time Parsing Utilities</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/logtk/index.html" title="C++ Logging Toolkit">C++ Logging Toolkit</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/sumtk/index.html" title="C++ Summation Toolkit">C++ Summation Toolkit</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/wykobi/index.html" title="Wykobi Computational Geometry Library">Wykobi Computational Geometry Library</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/schifra/index.html" title="Schifra Reed Solomon Error Correcting Code Library">Schifra Reed Solomon Error Correcting Code Library</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/makefile/index.html" title="C++ Makefile Template">C++ Makefile Template</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/registrymonitor/index.html" title="Win32 Registry Activity Monitor">Win32 Registry Activity Monitor</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/stringtokenizer/index.html" title="String Tokenizer">String Tokenizer</a>
                  <a class="leftmenu" href="http://www.partow.net/programming/polynomials/index.html" title="Primitive Polynomials">Primitive Polynomials</a>
                  <br>

                 <div class="dynacontent">
                  <p align="center"><img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/menu_logo.gif" alt="www.partow.net Menu Logo - Copyright Arash Partow" border="0"></p>
                 </div>

                 <div class="dynacontent">
                  <p align="center">
                   <a href="http://validator.w3.org/check/referer"><img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/valid-xhtml10-blue" alt="Valid XHTML 1.0!" border="0" height="31" width="88"></a>
                  </p>
                 </div>

               </div>


              </td>
              <td valign="top"><br>

                <table border="0" cellspacing="0" cellpadding="0" width="100%">
                  <tbody>
                    <tr>
                      <td width="10"></td>
                      <td valign="top" align="left" class="mainbox">

                       <h3 align="left">Description</h3>

                       <p align="left">
                        The C++ String Toolkit Library (StrTk) consists of robust, optimized and portable string
                        processing algorithms for the C++ language. StrTk is designed to be easy to use and
                        integrate within existing code bases. Furthermore the library has a rich set of features
                        that makes light work of any kind of string processing task.
                       </p>

                       <h3 align="left">Capabilities</h3>
                       <p align="left">
                         The StrTk library has the following capabilities:
                       </p>

                       <ul style="text-align: left">
                        <li>Generic string tokenizer and token iterators</li>
                        <li>Fast Split routines</li>
                        <li>User specified delimiter and splitter policies (simple and regex based etc.)</li>
                        <li>Conversions between data and hex and base-64</li>
                        <li>In-place removal and replace routines</li>
                        <li>Wild-card matching and globbing</li>
                        <li>Search and Replace</li>
                        <li>Fast token grid and Comma Separated Values (CSV and DSV) processing</li>
                        <li>Extremely fast String to Integer, Double and other POD conversions</li>
                        <li>Extensible string processing templates and algorithms (eg: combinatorics and randomizations)</li>
                        <li>Prefix tree and Bloom filter structures for efficient string matching and testing</li>
                        <li>Fast and simple-to-use binary serialization</li>
                        <li>Seamless integration with STL and Boost</li>
                        <li>Easy to use wrappers of common string processing usage patterns</li>
                        <li>Single header file solution requires no installation or building</li>
                       </ul>

                       <h3 align="left">C++ String Toolkit Library License</h3>
                       <p align="left">
                        Free use of the String Toolkit Library is permitted under the guidelines and in accordance with the
                        <a class="dash" href="http://www.opensource.org/licenses/MIT" title="MIT License">MIT License.</a>
                       </p>

                       <h3 align="left">Compatibility</h3>
                       <p align="left">
                         The C++ String Toolkit Library implementation is compatible with the following C++ compilers:
                       </p>

                        <ul style="text-align: left">
                         <li>GNU Compiler Collection (4.1+)</li>
                         <li>Intel® C++ Compiler (9.x+)</li>
                         <li>Clang/LLVM (1.1+)</li>
                         <li>PGI C++ (10.x+)</li>
                         <li>Microsoft Visual Studio C++ Compiler (7.1+)</li>
                         <li>IBM XL C/C++ (10.x+)</li>
                         <li>C++ Builder (XE4+)</li>
                        </ul>

                       <h3 align="left">Download</h3>
                       <ul style="text-align: left">
                        <li><h4><a href="http://www.partow.net/downloads/strtk.zip">String Toolkit Library Source Code and Examples</a></h4></li>
                        <li><h4><a href="http://www.partow.net/downloads/strtk_vc10_solution.zip">MSVC10 project solution</a></h4></li>
                        <li><h4><a href="http://www.partow.net/downloads/strtk_vc9_solution.zip">MSVC9 project solution</a></h4></li>
                        <li><h4><a href="http://www.partow.net/downloads/strtk_vc7_solution.zip">MSVC7 project solution</a></h4></li>
                       </ul>

                       <hr style="color:#3366FF">

                       <h2 align="left"><a name="tutorial">Quick Tutorial</a></h2>

                       <ul style="text-align: left; list-style-type:square">
                       <li><a href="http://www.partow.net/programming/strtk/index.html#Introduction%20To%20StrTk">Section 00 - Introduction To StrTk                                    </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#Delimiters">Section 01 - Delimiters                                               </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#Split">Section 02 - Split                                                    </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#SplitNTokens">Section 03 - Split N-Tokens                                           </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#Offset">Section 04 - Offset                                                   </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#SplitRegex">Section 05 - Split Regex                                              </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#Tokenizer">Section 06 - Tokenizer                                                </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#TheParseRoutine">Section 07 - The Parse Routine                                        </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#SomeSimpleParseExamples">Section 08 - Some Simple Parse Examples                               </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#SimpleExample0">Section 09 - Simple Example 0                                         </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#SimpleExample1">Section 10 - Simple Example 1                                         </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#SimpleExample2">Section 11 - Simple Example 2                                         </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#SimpleExample3">Section 12 - Simple Example 3                                         </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#SimpleExample4">Section 13 - Simple Example 4                                         </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#SimpleExample5">Section 14 - Simple Example 5                                         </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#APracticalExample">Section 15 - A Practical Example                                      </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#AnotherExample">Section 16 - Another Example                                          </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#SimpleDateTimeParser">Section 17 - Simple Date-Time Parser                                  </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#ParsingSubLists">Section 18 - Parsing Sub-Lists                                        </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#ParsingTrailingLists">Section 19 - Parsing Trailing-Lists                                   </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#ExtendingTheDateTimeParserExample">Section 20 - Extending The Date-Time Parser Example                   </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#TokenProcessingDuringParsing">Section 21 - Token Processing During Parsing                          </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#IgnoreTokenProcessing">Section 22 - Ignore Token Processing                                  </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#ExpectAndIExpectTokenProcessing">Section 23 - Expect And IExpect Token Processing                      </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#LikeTokenProcessing">Section 24 - Like Token Processing                                    </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#InRangeTokenProcessing">Section 25 - In-Range Token Processing                                </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#TrimTokenProcessing">Section 26 - Trim Token Processing                                    </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#CaseNormalisationTokenProcessing">Section 27 - Case Normalisation Token Processing                      </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#ParsingTruncatedValues">Section 28 - Parsing Truncated Values                                 </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#ColumnwiseParsing">Section 29 - Columnwise Parsing                                       </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#Simple3DMeshFileFormatParser">Section 30 - Simple 3D Mesh File Format Parser                        </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#Simple%20Semantic%20Actions">Section 31 - Simple Semantic Actions                                  </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#PickARandomLineFromATextFile">Section 32 - Pick A Random Line From A Text File                      </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#TheBuyLowAndSellHighProblem">Section 33 - The Buy Low And Sell High Problem                        </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#TokenGrid">Section 34 - Token Grid                                               </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#ProcessingOfCommaSeparatedValuesData">Section 35 - Processing Of Comma Separated Values Data (CSV)          </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#TIMTOWTDI">Section 36 - TIMTOWTDI                                                </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#TIMTOWTDI2">Section 37 - TIMTOWTDI 2.0 <em>(with a vengeance)</em>                </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#Sequential%20Partitions">Section 38 - Sequential Partitions                                    </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#ParsingCSVFilesWithEmbeddedDoubleQuotes">Section 39 - Parsing CSV Files With Embedded Double-Quotes            </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#ExtendingDelimiterPredicates">Section 40 - Extending Delimiter Predicates                           </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#HighPerformanceKeyValueParsing">Section 41 - High Performance Key-Value Parsing                       </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#KeyToValueMappers">Section 42 - Key To Value Mappers                                     </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#KeyValuePairsAndMultipleDistinctDataStructures">Section 43 - Key-Value Pairs And Multiple Distinct Data Structures    </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#KeyValuePairsAndLists">Section 44 - Key-Value Pairs And Lists                                </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#KeyValuePairsWithCardinalKeys">Section 45 - Key-Value Pairs With Cardinal Keys                       </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#OptionalKeyValuePairs">Section 46 - Optional Key-Value Pairs                                 </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#SemanticActionsWithKeyValuePairs">Section 47 - Semantic Actions With Key-Value Pairs                    </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#AnAttemptAtImprovingFileProcessingPerformance">Section 48 - An Attempt At Improving File Processing Performance      </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#MMapBenchmark">Section 49 - Memory Mapped File Benchmark using 'strtk::for_each_line'</a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#TheLettersGame">Section 50 - The Letters Game                                         </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#PerformanceComparisons">Section 51 - Performance Comparisons                                  </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#AFinalDigression">Section 52 - A Final Digression - Fast Integer To String Conversion   </a></li>
                       <li><a href="http://www.partow.net/programming/strtk/index.html#StrTkLibraryDependency">Section 53 - StrTk Library Dependency                                 </a></li>
                       </ul>

                       <h3 align="left"><a name="Introduction To StrTk">Introduction To StrTk</a></h3>
                       <p align="left">
                        The C++ String Toolkit Library (StrTk) is a general purpose string
                        processing library. It's design principles centers around efficiency
                        and ease of use. This tutorial will primarily cover string parsing and
                        tokenization functionalities of the library.<br><br>

                        StrTk provides two common tokenization concepts, a split function and
                        a token iterator. Both these concepts require the user to provide a
                        delimiter predicate and an iterator range over which the process will
                        be carried out.
                       </p>

                       <p align="left">
                        The tokenization process can be further parametrized by switching
                        between "compressed delimiters" or "no compressed delimiters" mode.
                        This essentially means that consecutive delimiters will be compressed
                        down to one and treated as such. Below are two tables depicting the
                        expected tokens from various types of input. The table below represent
                        'no compressed' and compressed tokenization processes respectively.
                        The delimiter in this instance is a pipe symbol | and &lt;&gt; denotes an
                        empty token.
                       </p>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#000000;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#000000;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#000000;color:#fff;background-color:#26ADE4;}
                       .tg .tg-sb2x{font-family:"Courier New", Courier, monospace !important;;color:#fe0000;text-align:center;vertical-align:top}
                       .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
                       .tg .tg-9hbo{font-weight:bold;vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr> <th class="tg-amwm" colspan="2">No Compressed Delimiters</th> <th class="tg-9hbo" colspan="2">Compressed Delimiters</th> </tr>
                         <tr> <td class="tg-amwm">Input</td> <td class="tg-amwm">Token List</td> <td class="tg-amwm">Input</td> <td class="tg-amwm">Token List</td> </tr>
                         <tr> <td class="tg-sb2x">a       </td> <td class="tg-sb2x">a                                               </td> <td class="tg-sb2x">a       </td> <td class="tg-sb2x">a                    </td> </tr>
                         <tr> <td class="tg-sb2x">a|b     </td> <td class="tg-sb2x">a,b                                             </td> <td class="tg-sb2x">a||b    </td> <td class="tg-sb2x">a,b                  </td> </tr>
                         <tr> <td class="tg-sb2x">a||b    </td> <td class="tg-sb2x">a,&lt;&gt;,b                                    </td> <td class="tg-sb2x">|a||b   </td> <td class="tg-sb2x">&lt;&gt;,a,b         </td> </tr>
                         <tr> <td class="tg-sb2x">|a      </td> <td class="tg-sb2x">&lt;&gt;,a                                      </td> <td class="tg-sb2x">||a||b||</td> <td class="tg-sb2x">&lt;&gt;,a,b,&lt;&gt;</td> </tr>
                         <tr> <td class="tg-sb2x">a|      </td> <td class="tg-sb2x">a,&lt;&gt;                                      </td> <td class="tg-sb2x">|       </td> <td class="tg-sb2x">&lt;&gt;,&lt;&gt;    </td> </tr>
                         <tr> <td class="tg-sb2x">|a||b   </td> <td class="tg-sb2x">&lt;&gt;,a,&lt;&gt;,b                           </td> <td class="tg-sb2x">||      </td> <td class="tg-sb2x">&lt;&gt;,&lt;&gt;    </td> </tr>
                         <tr> <td class="tg-sb2x">||a||b||</td> <td class="tg-sb2x">&lt;&gt;,&lt;&gt;,a,&lt;&gt;,b,&lt;&gt;,&lt;&gt;</td> <td class="tg-sb2x">|||     </td> <td class="tg-sb2x">&lt;&gt;,&lt;&gt;    </td> </tr>
                         <tr> <td class="tg-sb2x">|       </td> <td class="tg-sb2x">&lt;&gt;,&lt;&gt;                               </td> <td class="tg-sb2x">        </td> <td class="tg-sb2x">                     </td> </tr>
                         <tr> <td class="tg-sb2x">||      </td> <td class="tg-sb2x">&lt;&gt;,&lt;&gt;,&lt;&gt;                      </td> <td class="tg-sb2x">        </td> <td class="tg-sb2x">                     </td> </tr>
                         <tr> <td class="tg-sb2x">|||     </td> <td class="tg-sb2x">&lt;&gt;,&lt;&gt;,&lt;&gt;,&lt;&gt;             </td> <td class="tg-sb2x">        </td> <td class="tg-sb2x">                     </td> </tr>
                       </tbody></table>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="Delimiters">Delimiters</a></h3>
                       <p align="left">
                        Two forms of delimiters are supported and they are single delimiter
                        predicate and multiple delimiters predicate otherwise known as SDP and
                        MDP respectively. Essentially an SDP is where there is only one type
                        that can break or fragment the sequence, where as with MDPs there is
                        more than one unique type that can break the sequence. It is possible
                        to represent a SDP using the MDP, however from a performance POV
                        having separate predicates is far more efficient. Additionally for
                        strings based on char or unsigned char (8-bit versions) there is a MDP
                        that has a look-up complexity of O(1) making it greatly more efficient
                        than the basic MDP.
                       </p>

                       <h4 align="left">Single Delimiter Predicate</h4>
                       <p align="left">
                        Instantiation requires specialization of type and construction requires
                        an instance of the type.
                       </p>
                       <pre>
strtk::single_delimiter_predicate&lt;typename T&gt;(const T&amp; t)

strtk::single_delimiter_predicate&lt;std::string::value_type&gt; predicate('|');
                       </pre>

                       <h4 align="left">Multiple Delimiter Predicate</h4>
                       <p align="left">
                        Instantiation requires specialization of type and construction requires
                        a sequence of potential delimiters through a range described by iterators.
                       </p>
                       <pre>
strtk::multiple_delimiter_predicate&lt;typename T&gt;(Iterator begin, Iterator end);

std::string str_delimiters = " ,.;:&lt;&gt;'[]{}()_?/'`~!@#$%^&amp;*|-_\"=+";
strtk::multiple_delimiter_predicate<char> mdp1(str_delimiters.begin(),str_delimiters.end());

unsigned int uint_delimiters[5] = {1, 10, 101, 1010, 10101};
strtk::multiple_delimiter_predicate&lt;unsigned int&gt; mdp2(uint_delimiters,uint_delimiters + 5);
                       </char></pre>


                       <h4 align="left">Multiple Char Delimiter Predicate</h4>
                       <p align="left">
                        Instantiation requires an iterator range based on either unsigned char
                        or char. This delimiter is more efficient than the simple MDP as it
                        has a predicate evaluation of <b>O(1)</b> due to the use of a lookup-table
                        as opposed to <b>O(n)</b> where n is the number of delimiters. Performance
                        increase is seen as more delimiters are used.
                       </p>
                       <pre>strtk::multiple_char_delimiter_predicate(const std::string&amp;)

strtk::multiple_char_delimiter_predicate(const std::string::const_iterator begin,
                                         const std::string::const_iterator end)

//usage:
strtk::multiple_char_delimiter_predicate predicate(" .;?");
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="Split">Split</a></h3>
                       <p align="left">
                        This is a function that performs tokenization over an entire sequence
                        in one go. <b>strtk::split</b> takes a sequence through a range of
                        iterators or in the case of a string through a reference to its instance,
                        a delimiter predicate and an output iterator or otherwise known as a
                        type sink. It populates the output iterator with the tokens it
                        extracts. The tokens in this case are std::pairs of iterators for the
                        sequence.
                       </p>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_split_diagram.png" alt="C++ String Toolkit Library Split Routine Diagram - Copyright Arash Partow" border="0">
                       </p>

                       <p align="left">
                        Split can be used in a "simple - no frills" manner by simply passing
                        the necessary parameters:
                       </p>

                       <pre>
std::string str = "abc|123|xyz|789";
strtk::std_string::token_list_type token_list;
strtk::split(" |.;?", str, std::back_inserter(token_list));
                       </pre>

                       <p align="left">
                        <b>strtk::split</b> can also be used in a more explicit manner whereby
                        the exact type of delimiter predicate can be specified by the user:
                       </p>

                       <pre>
// split using strtk predicates
{
   std::string str = "abc|123|xyz|789";
   strtk::std_string::token_list_type token_list;

   strtk::single_delimiter_predicate<std::string::value_type> predicate('|');
   strtk::split(predicate, str, std::back_inserter(token_list));
}

// split using a lambda as a predicate
{
   std::string data = "abc|123|xyz|789";
   std::deque&lt;std::string&gt; token_list;
   strtk::split([](const char c)
                {
                   return '|' == c;
                },
                data,
                strtk::range_to_type_back_inserter(token_list));
}
                       </std::string::value_type></pre>

                       <p align="left">
                        <b>strtk::split</b> provides an additional usage option that allows the user
                        to specify if they would like to either compress the delimiters and
                        whether or not they would like to include the delimiter as part of the
                        token range. This enum parameter is called <b>strtk::split_options</b> and
                        has the following values:
                       </p>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 20px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 20px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-e3zv{font-weight:bold}
                       </style>
                       <table class="tg">
                         <tbody><tr> <th class="tg-e3zv">Split Option</th> <th class="tg-e3zv">Definition</th> </tr>
                         <tr> <td class="tg-031e">strtk::split_options::default_mode         </td> <td class="tg-031e">Default options                                             </td> </tr>
                         <tr> <td class="tg-031e">strtk::split_options::compress_delimiters  </td> <td class="tg-031e">Consecutive delimiters are treated as one                   </td> </tr>
                         <tr> <td class="tg-031e">strtk::split_options::include_1st_delimiter</td> <td class="tg-031e">The first delimiter is included in the resulting token range</td> </tr>
                         <tr> <td class="tg-031e">strtk::split_options::include_delimiters   </td> <td class="tg-031e">All delimiters are included in the resulting token range    </td> </tr>
                       </tbody></table>

                       <p align="left">
                        The simple example below demonstrates a split that will occur over a
                        string given a predicate where the provided split options indicate
                        that consecutive delimiters will be treated as one and also all
                        delimiters encountered after each token will also be included in the
                        token up until the next token begins.
                       </p>

                       <pre>
strtk::split(predicate,
             str,
             std::back_inserter(token_list),
             strtk::split_options::compress_delimiters |
             strtk::split_options::include_delimiters);
                       </pre>

                       <p align="left">
                        Another way of using split may be to use the
                        strtk::multiple_char_delimiter_predicate as follows:
                       </p>

                       <pre>
std::string str = "abc?123;xyz.789";

strtk::std_string::token_list_type token_list;

strtk::multiple_char_delimiter_predicate predicate(" .;?");

strtk::split(predicate, str, std::back_inserter(token_list));
                       </pre>

                       <p align="left">
                        The contents of the token_list can be printed out as follows:
                       </p>

                       <pre>
strtk::std_string::token_list_type::iterator itr = token_list.begin();

while (token_list.end() != itr)
{
   std::cout &lt;&lt; (*itr) &lt;&lt; '\t';
   ++itr;
}
                       </pre>


                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="SplitNTokens">Split N-Tokens</a></h3>
                       <p align="left">
                        A natural extension of strtk::split is <b>strtk::split_n</b>. This function
                        provides the ability to tokenize a sequence up until a specific number
                        of tokens have been encountered or until there are no more tokens left.
                        The return value of the <b>strtk::split_n</b> would be the number of
                        tokens encountered.
                       </p>

                       <pre>
std::string data = "token1?token2,token3;token4,token5";

strtk::std_string::token_list_type token_list;

const std::size_t token_count = 4;
const std::string delimiters (" ,.;?");

strtk::split_n(delimiters,
               data,
               token_count,
               std::back_inserter(token_list));

strtk::std_string::token_list_type::iterator itr = token_list.begin();

while (token_list.end() != itr)
{
   std::cout &lt;&lt; "[" &lt;&lt; (*itr) &lt;&lt; "]\t";
   ++itr;
}

std::cout &lt;&lt; std::endl;
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="Offset">Offset</a></h3>
                       <p align="left">
                        Another simple variant is the <b>strtk::offset_splitter</b>. This form
                        of split takes a series of offsets and an iterator range or string and
                        determines the tokens based on the offsets. This function can be set to
                        perform a single pass of the offsets or to rotate them until the range
                        has been completely traversed. The example below demonstrates how a
                        string representing date and time can be tokenized into its constituent
                        parts <em>(year, month, day, hour, minutes, seconds, milliseconds)</em>
                       </p>

                       <pre>
std::string time_data = "20000101091011345"; // 2000-01-01 9:10:11sec 345ms

const std::size_t offset_list_size = 7;
const int offset_list[offset_list_size] = {
                                            4, // year
                                            2, // month
                                            2, // day
                                            2, // hour
                                            2, // minute
                                            2, // second
                                            3  // ms
                                          };

const strtk::offset_predicate<offset_list_size> predicate(offset_list);

strtk::std_string::token_list_type token_list;
strtk::offset_splitter(time_data,predicate,std::back_inserter(token_list));

strtk::std_string::token_list_type::iterator itr = token_list.begin();

while (token_list.end() != itr)
{
   std::cout &lt;&lt; "[" &lt;&lt; (*itr) &lt;&lt; "] ";
   ++itr;
}

std::cout &lt;&lt; std::endl;
                       </offset_list_size></pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="SplitRegex">Split Regex</a></h3>
                       <p align="left">
                        Another form of splitter is based on the concept of using regular
                        expressions as the delimiter predicate. Below is a simple example of
                        splitting tokens wrapped in round-brackets.
                       </p>

                       <pre>
std::string str = "(12)(345)(6789)(0ijkx)(yz)";

std::list&lt;std::string&gt; token_list;

strtk::split_regex("\\(.*?\\)",
                   s,
                   std::back_inserter(token_list),
                   strtk::regex_match_mode::match_1);

std::list&lt;std::string&gt;::iterator itr = token_list.begin();

while (token_list.end() != itr)
{
   std::cout &lt;&lt; "[" &lt;&lt; (*itr) &lt;&lt; "]\t";
   ++itr;
}

std::cout &lt;&lt; std::endl;
                       </pre>

                       <p align="left">
                        <b>Note</b>: The parameter regex_match_mode represents the capture of
                        the marked sub-pattern in the current match. By default it is
                        <b>strtk::regex_match_mode::match_all</b> which in this case would provide
                        the entire match including the bounding pattern, eg: Token3 would be
                        (0ijkx). <br> <br>
                        However in the above example we are only interested in the
                        sub-pattern between the round-brackets, hence <b>strtk::regex_match_mode::match_1</b>
                        is used resulting in Token3 being 0ijkx.
                       </p>

                       <p align="left">
                        The following examples demonstrate the use of <b>strtk::split_regex</b> and
                        <b>strtk::split_regex_n</b> routines in extracting specific types of data -
                        in this case the POD types int and double.
                       </p>

                       <pre>
int main()
{
   {
      // Extract ints from data string
      std::string data = "a 1^bc,0023| def?gh(4567ijk)-89 10l,m$n-op+123r@st+3u v*w2y56yz+";
      std::deque&lt;int&gt; int_list;
      strtk::split_regex("([+-]?([\\d]+))",
                         data,
                         strtk::range_to_type_back_inserter(int_list),
                         strtk::regex_match_mode::match_1);
   }

   {
      // Extract doubles from data string
      std::string data = "ab$c1.1?d-2.2ef#ghi+3.3%(123.456)!&amp;*-7.89E+12@^=";
      std::deque&lt;double&gt; double_list;
      strtk::split_regex(strtk::ieee754_expression,
                         data,
                         strtk::range_to_type_back_inserter(double_list),
                         strtk::regex_match_mode::match_1);
   }

   {
      // Extract the first 3 ints from data string
      std::string data = "a 1^bc,0023| def?gh(4567ijk)-89 10l,m$n-op+123r@st+3u v*w2y56yz+";
      std::deque&lt;int&gt; int_list;
      strtk::split_regex_n("([+-]?([\\d]+))",
                           data,
                           3,
                           strtk::range_to_type_back_inserter(int_list),
                           strtk::regex_match_mode::match_1);
   }

   {
      // Extract the first 4 doubles from data string
      std::string data = "ab$c1.1?d-2.2ef#ghi+3.3%(123.456)!&amp;*-7.89E+12@^=";
      std::deque&lt;double&gt; double_list;
      strtk::split_regex_n(strtk::ieee754_expression,
                           data,
                           4,
                           strtk::range_to_type_back_inserter(double_list),
                           strtk::regex_match_mode::match_1);
   }

   return 0;
}
                       </pre>

                       <p align="left">
                        The following table describes the various regex patterns built into
                        StrTk which can be used seamlessly with the <b>strtk::split_regex</b> and
                        <b>strtk::split_regex_n</b> routines.
                       </p>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 20px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 20px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-e3zv{font-weight:bold}
                       </style>
                       <table class="tg">
                         <tbody><tr> <th class="tg-e3zv">Regex</th> <th class="tg-e3zv">Definition</th> </tr>
                         <tr> <td class="tg-031e">strtk::uri_expression    </td> <td class="tg-031e">URI, URL address<br>e.g.: http://www.example.com, domain.example.net/index.html</td> </tr>
                         <tr> <td class="tg-031e">strtk::email_expression  </td> <td class="tg-031e">E-mail address<br>e.g.: some.one@example.com                                   </td> </tr>
                         <tr> <td class="tg-031e">strtk::ip_expression     </td> <td class="tg-031e">IPv4 address<br>e.g.: 192.168.0.1, 127.0.0.1                                   </td> </tr>
                         <tr> <td class="tg-031e">strtk::ieee754_expression</td> <td class="tg-031e">Floating point value<br>e.g.: 1.1, 1.234e-123, -1.0001E+10, 0.1234             </td> </tr>
                       </tbody></table>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="Tokenizer">Tokenizer</a></h3>
                       <p align="left">
                        The tokenizer is specialized on a sequence iterator and predicate. It
                        is constructed with a range of iterators for the sequence and a
                        reference to the desired predicate. Definitions exist for std::string
                        tokenizers. The tokenizer provides an iteration pattern as a means for
                        accessing the tokens in the sequence.
                       </p>

                       <pre>
const unsigned int data_size = 12;
unsigned int data[data_size] = {1, 2, 3, 0, 4, 5, 6, 0, 7, 8, 0, 9};
strtk::single_delimiter_predicate<unsigned int=""> predicate(0);
typedef strtk::tokenizer<unsigned int*,strtk::single_delimiter_predicate<unsigned="" int=""> &gt; tokenizer_type;
tokenizer_type tokenizer(data, data + data_size, predicate);
                       </unsigned></unsigned></pre>

                       <p align="left">
                        Similar to that of strtk::split, strtk::tokenizer provides tokenizing
                        options that are passed in during construction. Below is a table
                        depicting said options:
                       </p>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 20px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 20px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-e3zv{font-weight:bold}
                       </style>
                       <table class="tg">
                         <tbody><tr> <th class="tg-e3zv">Tokenize Option</th> <th class="tg-e3zv">Definition</th> </tr>
                         <tr> <td class="tg-031e">strtk::tokenize_options::default_mode         </td> <td class="tg-031e">Default options                                             </td> </tr>
                         <tr> <td class="tg-031e">strtk::tokenize_options::compress_delimiters  </td> <td class="tg-031e">Consecutive delimiters are treated as one                   </td> </tr>
                         <tr> <td class="tg-031e">strtk::tokenize_options::include_1st_delimiter</td> <td class="tg-031e">The first delimiter is included in the resulting token range</td> </tr>
                         <tr> <td class="tg-031e">strtk::tokenize_options::include_delimiters   </td> <td class="tg-031e">All delimiters are included in the resulting token range    </td> </tr>
                       </tbody></table>

                       <pre>
typedef strtk::single_delimiter_predicate&lt;unsigned int&gt; sdp_t;
typedef strtk::tokenizer&lt;unsigned int*,sdp_t&gt; tokenizer_type;

tokenizer_type tokenizer(data, data + data_size,
                         predicate,
                         strtk::tokenize_options::compress_delimiters |
                         strtk::tokenize_options::include_1st_delimiter);

                       </pre>

                       <p align="left">
                        Furthermore, iteration over tokens using strtk::tokenizer is performed
                        as follows:
                       </p>

                       <pre>
tokenizer_type::iterator itr = tokenizer.begin();

while (tokenizer.end() != itr)
{
   std::copy((*itr).first,(*itr).second,std::ostream_iterator<unsigned int="">(std::cout," "));
   std::cout &lt;&lt; std::endl;

   ++itr;
}
                       </unsigned></pre>

                       <p align="left">
                        A typical <b>std::string</b> can be tokenized in the following manner:
                       </p>

                       <pre>
std::string str = "abc|123|xyz|789";

strtk::std_string::tokenizer&lt;&gt;::type tokenizer(str,"|");
strtk::std_string::tokenizer&lt;&gt;::type::iterator itr = tokenizer.begin();

while (tokenizer.end() != itr)
{
   std::cout &lt;&lt; "[" &lt;&lt; (*itr) &lt;&lt; "]\t";

   ++itr;
}

std::cout &lt;&lt; std::endl;
                       </pre>

                       <p align="left">
                        Another common situation may be tokenizing a sequence of
                        strings, such as the following:
                       </p>

                       <pre>const std::string str_list[] = { "abc" , "delimiter" , "ijk" , "delimiter" ,
                                 "mno" , "delimiter" , "rst" , "uvw" ,
                                 "delimiter" , "xyz" };

const std::size_t str_list_size = sizeof(str_list) / sizeof(std::string);

strtk::range_adapter&lt;std::string&gt; range(str_list,str_list_size);
strtk::single_delimiter_predicate&lt;std::string&gt; predicate("delimiter");

typedef strtk::tokenizer
            &lt;std::string*,strtk::single_delimiter_predicate&lt;std::string&gt; &gt; tokenizer_type;

tokenizer_type tokenizer(range.begin(), range.end(), predicate);
tokenizer_type::iterator itr = tokenizer.begin();

while (tokenizer.end() != itr)
{
   std::copy((*itr).first, (*itr).second, std::ostream_iterator&lt;std::string&gt;(std::cout," "));
   std::cout &lt;&lt; std::endl;

   ++itr;
}
                       </pre>

                       <p align="left">
                        <b>Note:</b> For performance and efficient resource management purposes
                        the <b>strtk::tokenizer</b> does not take ownership or make an internal
                        copy of the sequence being tokenized, as such the strtk::tokenizer expects
                        the range to be valid during the entirety of the tokenization process,
                        this is also the case for the specified predicate.
                       </p>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="TheParseRoutine">The Parse Routine</a></h3>
                       <p align="left">
                        Till now the mentioned routines worked specifically with tokens, or in
                        other words ranges of characters. The responsibility of managing the
                        tokens and converting the tokens to user specified types was done manually
                        via "range to type" oriented back inserters and converters. This can be a
                        bit cumbersome and as such StrTk provides a series of helper routines called
                        <b>strtk::parse</b>. Parse takes an std::string representing a tuple of
                        delimited values as input data, a delimiter set, and a series of references
                        to variables that are to be populated with the values from the parsed tokens.
                        The following diagram demonstrates the flow of data, tokens and the corresponding
                        relationships and conversions between each of the parameters.
                       </p>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_parse_diagram.png" alt="C++ String Toolkit Library Parse Routine Diagram - Copyright Arash Partow" border="0">
                       </p>

                       <p align="left">
                        <b>Note:</b> strtk::parse returns a boolean value of true upon
                        successful parsing and false for all other results. Situations that
                        cause strtk::parse to fail include:
                       </p>

                       <ul style="text-align: left">
                        <li>Insufficient number of tokens for the given number of variables</li>
                        <li>Conversion failure from token range to variable type</li>
                        <li>Empty or null token(s)</li>
                       </ul>

                       <h3 align="left"><a name="SomeSimpleParseExamples">Some Simple Parse Examples</a></h3>
                       <p align="left">
                        <b>strtk::parse</b> can take an arbitrary number of variable references. The
                        code below demonstrates the basic usage of strtk::parse taking various
                        number of parameters.
                       </p>

                       <pre>
std::string data = "abcde,-1234|567.890#1.1f";
std::string delimiters = ",|#";

std::string var0;
int var1;
double var2;
float var3;

strtk::parse(data, delimiters, var0);

strtk::parse(data, delimiters, var0, var1);

strtk::parse(data, delimiters, var0, var1, var2);

strtk::parse(data, delimiters, var0, var1, var2, var3);
                       </pre>

                       <p align="left">
                        The following examples demonstrate parsing of PODs such as int and
                        double into STL compatible sequences (std::vector, std::deque,
                        std::list, std::set, std::queue, std::stack and std::priority_queue).
                       </p>

                       <pre>
// Insert into std::vector
std::string int_string = "1 +2 -3 4 +5 -6 7 +8 -9 10 +11 -12 13 +14 -15";
std::vector&lt;int&gt; int_vector;
strtk::parse(int_string, " ", int_vector);

// Insert into std::deque
std::string double_string = "-123.456,789.012,-345.678,901.234,+567.890";
std::deque&lt;double&gt; double_deque;
strtk::parse(double_string, ",", double_deque);

// Insert into std::list
std::string data_string = "a,bc,def,ghij,klmno,pqrstu,vwxyz";
std::list&lt;std::string&gt; string_list;
strtk::parse(data_string, ",", string_list);

// Insert into std::set
std::string set_string = "a|bc#def|ghij#klmno|pqrstu#vwxyz";
std::set&lt;std::string&gt; string_set;
strtk::parse(set_string, "#|", string_set);

// Insert into std::queue
std::string queue_string = "value1,value2,value3,value4,value5";
std::queue&lt;std::string&gt; string_queue;
strtk::parse(queue_string, ",|", string_queue);

// Insert into std::stack
std::string stack_string = "value1|value2,value3|value4,value5";
std::stack&lt;std::string&gt; string_stack;
strtk::parse(stack_string, ",|", string_stack);

// Insert into std::priority_queue
std::string priority_queue_string = "value1|value2,value3#value4,value5";
std::priority_queue&lt;std::string&gt; string_priority_queue;
strtk::parse(priority_queue_string, ",|#", string_priority_queue);
                       </pre>

                       <p align="left">
                        Similar to what is described above, the following demonstrates parsing
                        of up to "N" elements into an STL compatible sequence.
                       </p>

                       <pre>
// Insert 5 elements into std::vector
std::string int_string = "100,-200,+300,400,-500,+600,700,-800,+900";
std::vector&lt;int&gt; int_vector;
strtk::parse_n(int_string, ",", 5, int_vector);

// Insert 3 elements into std::deque
std::string double_string = "123.456,+789.012,345.678,-901.234,567.890";
std::deque&lt;double&gt; double_deque;
strtk::parse_n(double_string, ",", 3, double_deque);

// Insert 6 elements into std::list
std::string data_string = "a,bc,def,ghij,klmno,pqrstu,vwxyz";
std::list&lt;std::string&gt; string_list;
strtk::parse_n(data_string, ",", 6, string_list);

// Insert 6 elements into std::set
std::string set_string = "a|bc#def|ghij#klmno|pqrstu#vwxyz";
std::set&lt;std::string&gt; string_set;
strtk::parse_n(set_string, "#|", 6, string_set);

// Insert 4 elements into std::queue
std::string queue_string = "value0,value1,value2,value3,value4,value5";
std::queue&lt;std::string&gt; string_queue;
strtk::parse_n(queue_string, ",|", 4, string_queue);

// Insert 4 elements into std::stack
std::string stack_string = "value0|value1|value2,value3|value4,value5";
std::stack&lt;std::string&gt; string_stack;
strtk::parse_n(stack_string, ",|", 4, string_stack);

// Insert 4 elements into std::priority_queue
std::string priority_queue_string = "value0#value1|value2,value3#value4,value5";
std::priority_queue&lt;std::string&gt; string_priority_queue;
strtk::parse_n(priority_queue_string, ",|#", 4, string_priority_queue);
                       </pre>

                       <p align="left">
                        <b>Note:</b> The return value of the routine strtk::parse_n indicates
                        how many elements were parsed and placed into the specified sequence.
                       </p>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="SomeInitialSimpleExamples">Some Initial Simple Examples</a></h3>
                       <h3 align="left"><a name="SimpleExample0">Simple Example 0</a></h3>
                       <p align="left">
                        As a first example, we'll tackle the simple problem of reversing words
                        in a sentence. That is given a sentence, to have the first word be the
                        last and the last to be the first, the second word to be the second
                        last so on and so forth. Using StrTk we come up with the following
                        solution:
                       </p>

                       <pre>
int main()
{
   std::string sentence = "The quick brown fox jumps over the lazy dog";
   std::cout &lt;&lt; "Before: " &lt;&lt; sentence &lt;&lt; std::endl;
   strtk::split(" ",
                sentence,
                strtk::functional_inserter(
                   [](const strtk::range::string&amp; range)
                   { strtk::reverse(range); })
               );

   strtk::reverse(sentence);

   std::cout &lt;&lt; "After: " &lt;&lt; sentence &lt;&lt; std::endl;

   return 0;
}
                       </pre>

                       <p align="left">
                        With an expected output of:
                       </p>

                       <pre>
Before: The quick brown fox jumps over the lazy dog
After: dog lazy the over jumps fox brown quick The
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="SimpleExample1">Simple Example 1</a></h3>
                       <p align="left">
                        Another example, given a list of words to blank out and a sentence,
                        transform the sentence such that the blank-out words are removed.
                        Using StrTk we come up with the following solution:
                       </p>

                       <pre>int main()
{
   std::string sentence = "The quick brown fox jumps over the lazy dog";

   std::unordered_set&lt;std::string&gt; blankout_words;
   blankout_words.insert("quick");
   blankout_words.insert("over");
   blankout_words.insert("lazy");

   std::cout &lt;&lt; "Before: " &lt;&lt; sentence &lt;&lt; std::endl;

   strtk::split(" ",
                sentence,
                strtk::functional_inserter(
                   [&amp;blankout_words](const strtk::range::string&amp; range)
                   {
                      auto itr = blankout_words.find(range);

                      if (blankout_words.end() != itr)
                      {
                         strtk::fill(range,' ');
                      }
                   })
               );

   strtk::remove_consecutives_inplace(' ',sentence);

   std::cout &lt;&lt; "After: " &lt;&lt; sentence &lt;&lt; std::endl;

   return 0;
}

                       </pre>

                       <p align="left">
                        With an expected output of:
                       </p>

                       <pre>
Before: The quick brown fox jumps over the lazy dog
After: The brown fox jumps the dog
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="SimpleExample2">Simple Example 2</a></h3>
                       <p align="left">
                        Another simple example would be given a text file to read each of the
                        lines and populate a word list structure by tokenizing each line into
                        words. The following is an example of how this can be achieved using
                        StrTk:
                       </p>

                       <pre>
int main()
{
   std::deque&lt;std::string&gt; word_list;
   strtk::for_each_line("text.txt",
                        [&amp;word_list](const std::string&amp; line)
                        {
                           static const std::string delimiters = "0123456789()[]{}&lt;&gt;"
                                                                 "\t\r\n ,,.;:'"
                                                                 "!@#$%^&amp;*_-=+`~/";

                           strtk::parse(line,delimiters,word_list);
                        });
   return 0;
}
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="SimpleExample3">Simple Example 3</a></h3>
                       <p align="left">
                        The following simple example takes a user specified text file,
                        proceeds to process it and returns information relating to the
                        file, such as word, letter, uppercase character, lowercase character,
                        vowel and consonant counts.
                       </p>

                       <pre>
int main()
{
   std::size_t word_count      = 0;
   std::size_t letter_count    = 0;
   std::size_t uppercase_count = 0;
   std::size_t lowercase_count = 0;
   std::size_t vowel_count     = 0;
   std::size_t consonant_count = 0;

   using namespace strtk;

   typedef multiple_char_delimiter_predicate mcdp_t;

   static const mcdp_t is_vowel("AEIOUaeiou");
   static const mcdp_t is_lowercase(ext_string::all_lowercase_letters());

   static const std::string delimiters = ext_string::all_chars()
                                       - ext_string::all_lowercase_letters()
                                       - ext_string::all_uppercase_letters();

   for_each_line("data.txt",
                 [&amp;](const std::string&amp; line)
                 {
                    split(delimiters,
                          line,
                          functional_inserter(
                             [&amp;](const strtk::range::string&amp; range)
                             {
                                if (0 == range.size()) return;

                                ++word_count;
                                letter_count += range.size();

                                std::size_t current_lowercase_count = 0;
                                std::size_t current_vowel_count     = 0;

                                for (std::size_t i = 0; i &lt; range.size(); ++i)
                                {
                                   if (is_vowel(range[i])) ++current_vowel_count;

                                   if (is_lowercase(range[i])) ++current_lowercase_count;
                                }

                                uppercase_count += range.size() - current_lowercase_count;
                                lowercase_count += current_lowercase_count;
                                consonant_count += range.size() - current_vowel_count;
                                vowel_count     += current_vowel_count;
                             })
                         );
                 });

   std::cout &lt;&lt; "Word count:      " &lt;&lt; word_count      &lt;&lt; std::endl;
   std::cout &lt;&lt; "Letter count:    " &lt;&lt; letter_count    &lt;&lt; std::endl;
   std::cout &lt;&lt; "Uppercase count: " &lt;&lt; uppercase_count &lt;&lt; std::endl;
   std::cout &lt;&lt; "Lowercase count: " &lt;&lt; lowercase_count &lt;&lt; std::endl;
   std::cout &lt;&lt; "Vowel count:     " &lt;&lt; vowel_count     &lt;&lt; std::endl;
   std::cout &lt;&lt; "Consonant count: " &lt;&lt; consonant_count &lt;&lt; std::endl;

   return 0;
}
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="SimpleExample4">Simple Example 4</a></h3>
                       <p align="left">
                        For the next example, assume we have a text file with a list of
                        names, one per line that represents the order of people that entered
                        a building. Some of the people may enter and leave then reenter the
                        building many times, hence their name will appear multiple times in
                        the list. Our task is to reduce this list to a list of unique names
                        but to also maintain the relative order of names found in the original
                        list. The following is how this particular requirement can be
                        accomplished by using StrTk:

                       </p>

                       <pre>
int main()
{
   strtk::for_each_line("file_name.txt",
                        [](const std::string&amp; line)
                        {
                           static std::unordered_set&lt;std::string&gt; line_set;

                           if (line_set.end() != line_set.find(line))
                              return;

                           line_set.insert(line);

                           std::cout &lt;&lt; line &lt;&lt; std::endl;
                        });
   return 0;
}
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="SimpleExample5">Simple Example 5</a></h3>
                       <p align="left">
                        As a final simple example, we would like to calculate the word
                        frequency model of a user specified text file. The process involves
                        reading each line, splitting the line into words, then incrementing
                        the relevant count for each word and maintaining a global word count.
                        Once the file has been processed, the occurrence frequency of each
                        word will be printed to stdout.
                       </p>

                       <pre>
int main()
{
   typedef std::unordered_map&lt;std::string,unsigned int&gt; map_t;

   map_t word_hit_list;

   unsigned int word_count = 0;

   strtk::for_each_line("data.txt",
                        [&amp;](const std::string&amp; line)
                        {
                           static const std::string delimiters
                              = strtk::ext_string::all_chars()
                              - strtk::ext_string::all_lowercase_letters()
                              - strtk::ext_string::all_uppercase_letters();

                            strtk::split(delimiters,
                                         line,
                                         strtk::functional_inserter(
                                            [&amp;](const strtk::range::string&amp; range)
                                            {
                                               if (range.begin() == range.end()) return;

                                               ++word_count;

                                               std::string word(range.begin(),range.end());

                                               ++word_hit_list[word];
                                            })
                                        );
                        });

   for (map_t::value_type v : word_hit_list)
   {
      printf("%s %10d %10.9f\n",
             strtk::text::right_align(15,' ',v.first).c_str(),
             v.second,
             (1.0 * v.second) / word_count);
   }

   return 0;
}
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="APracticalExample">A Practical Example</a></h3>
                       <p align="left">
                        Lets assume we have been given an English text file to process, with
                        the intention of extracting a lexicon from the file.
                       </p>

                       <p align="left">
                        One solution would be to break the problem down to a line by line
                        tokenization problem. In this case we would define a functional object
                        such as the following which will take the container in which we plan
                        on storing our tokens <em>(words)</em> and a predicate and insert the
                        tokens as strings into our container.
                       </p>

                       <pre>
template &lt;typename Container, typename Predicate&gt;
struct parse_line
{
public:

   parse_line(Container&amp; container, const Predicate&amp; predicate)
   : container_(container),
     predicate_(predicate)
   {}

   void operator() (const std::string&amp; str)
   {
      strtk::split(str,
                   predicate_,
                   strtk::range_to_type_back_inserter(container_),
                   strtk::split_options::compress_delimiters);
   }

private:

   Container&amp; container_;
   const Predicate&amp; predicate_;
};
                       </pre>

                       <p align="left">
                        The whole thing together would include a process of opening the file
                        and reading it line by line each time invoking the parse_line would be
                        as follows:
                       </p>

                       <pre>
template &lt;typename Container&gt;
void parse_text(const std::string&amp; file_name, Container&amp; c)
{
   static const std::string delimiters = " ,.;:&lt;&gt;'[]{}()_?/"
                                         "`~!@#$%^&amp;*|-_\"=+\t\r\n\0"
                                         "0123456789";

   strtk::multiple_char_delimiter_predicate predicate(delimiters);

   strtk::for_each_line(file_name,
                        parse_line<container,strtk::multiple_char_delimiter_predicate>(c,predicate));
}

int main()
{
   std::string text_file_name = "text.txt";

   std::deque&lt;std::string&gt; word_list;

   parse_text(text_file_name,word_list);

   std::cout &lt;&lt; "Token Count: " &lt;&lt; word_list.size() &lt;&lt; std::endl;

   return 0;
}
                       </container,strtk::multiple_char_delimiter_predicate></pre>


                       <p align="left">
                        Before we continue on with the example, a re-written version
                        of the above code using C++11 lambdas is as follows:
                       </p>

                       <pre>
int main()
{
   std::string text_file_name = "text.txt";

   std::deque&lt;std::string&gt; word_list;

   strtk::for_each_line(text_file_name,
                        [&amp;word_list](const std::string&amp; line)
                        {
                           static const std::string delimiters = " ,.;:&lt;&gt;'[]{}()_?/"
                                                                 "`~!@#$%^&amp;*|-_\"=+\t\r\n\0"
                                                                 "0123456789";

                           strtk::parse(line,delimiters,word_list);
                        });

   std::cout &lt;&lt; "Token Count: " &lt;&lt; word_list.size() &lt;&lt; std::endl;

   return 0;
}
                       </pre>

                       <p align="left">
                        Now coming back to the original problem, that being the construction
                        of a lexicon. In this case the set of "words" should only contain
                        words of interest. For the sake of simplicity lets define words of
                        interest as being anything other than the following prepositions: as,
                        at, but, by, for, in, like, next, of, on, opposite, out, past, to, up
                        and via. This type of list is commonly known as a <b>Stop Word List</b>.
                        In this example the stop-word list definition will be as follows:
                       </p>

                       <pre>
const std::string stop_word_list [] =
                  {
                     "as", "at", "but", "by", "for",
                     "in", "like", "next", "of", "on",
                     "opposite", "out", "past", "to",
                     "up", "via", ""
                  };

const std::size_t stop_word_list_size = sizeof(stop_word_list) / sizeof(std::string);
                       </pre>

                       <p align="left">
                        Some minor updates to the parse_line processor include using the
                        <b>filter_on_match</b> predicate for determining if the currently processed
                        token is a preposition and also the invocation of the range_to_type
                        back_inserter to convert the tokens from their range iterator
                        representation to a type representation compatible with the user
                        defined container. For the new implementation to provide unique words
                        of interest the simplest change that can be made is to replace the
                        deque used as the container for the <b>word_list</b> to some kind of 1-1
                        associative container such as a set. The following is the improved
                        version of the parse_line processor:
                       </p>

                       <pre>
template &lt;typename Container, typename Predicate&gt;
struct parse_line
{
public:

   parse_line(Container&amp; container, const Predicate&amp; predicate)
   : container_(container),
     predicate_(predicate),
     tmp_(" "),
     tokenizer_(tmp_,predicate_,true),
     filter_(stop_word_list,stop_word_list + stop_word_list_size,
             strtk::range_to_string_back_inserter_iterator&lt;Container&gt;(container_),
             true,false)
   {}

   void operator() (const std::string&amp; s)
   {
      const filter_type&amp; filter = filter_;

      strtk::for_each_token(s,tokenizer_,filter);
   }

private:

   Container&amp; container_;
   const Predicate&amp; predicate_;
   std::string tmp_;
   typename strtk::std_string_tokenizer&lt;Predicate&gt;::type tokenizer_;
   strtk::filter_on_match&lt;strtk::range_to_string_back_inserter_iterator&lt;Container&gt;&gt; filter_;
};
                       </pre>

                       <p align="left">
                        The above described predicate can be greatly simplified by using
                        binders and various lambda expressions.
                       </p>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="AnotherExample">Another Example</a></h3>
                       <p align="left">
                        When performing serialization or deserialization of an instance object
                        such as a class or struct, a simple approach one could take would be
                        to take each of the members and convert them into string
                        representations and from those strings construct a larger string
                        delimiting each member with a special character guaranteed not to
                        exist in any of the string representations.
                       </p>

                       <p align="left">
                        In this example we will assume that there exists a struct which
                        represents the properties of a person, a person struct if you will:
                       </p>

                       <pre>
struct person
{
   unsigned int id;
   std::string name;
   unsigned int age;
   double height
   float weight;
};
                       </pre>

                       <p align="left">
                        The process of populating a person struct would entail having an
                        instance of a person and the necessary data string. The following is
                        an example of how this would be done using the strtk::parse function.
                       </p>

                       <h4 align="left">Person Tuple Format</h4>

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;border-color:#999;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 1px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 1px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
.tg .tg-s6z2{text-align:center}
.tg .tg-hgcj{font-weight:bold;text-align:center}
</style>
<table class="tg">
  <tbody><tr>
    <th class="tg-hgcj">Token0</th>
    <th class="tg-hgcj">Delimiter0</th>
    <th class="tg-hgcj">Token1</th>
    <th class="tg-hgcj">Delimiter1</th>
    <th class="tg-hgcj">Token2</th>
    <th class="tg-hgcj">Delimiter2</th>
    <th class="tg-hgcj">Token3</th>
    <th class="tg-hgcj">Delimiter3</th>
    <th class="tg-hgcj">Token4</th>
  </tr>
  <tr>
    <td class="tg-s6z2">Unique ID(hex)</td>
    <td class="tg-s6z2">|</td>
    <td class="tg-s6z2">Name</td>
    <td class="tg-s6z2">|</td>
    <td class="tg-s6z2">Age</td>
    <td class="tg-s6z2">|</td>
    <td class="tg-s6z2">Height(m)</td>
    <td class="tg-s6z2">|</td>
    <td class="tg-s6z2">Weight(kg)</td>
  </tr>
</tbody></table>


                       <pre>
std::string data = "0xFA37ED12|Rumpelstiltskin|397|1.31|58.7";
person p;
strtk::hex_to_number_sink&lt;unsigned int&gt; hex_sink(p.id); // register id with the hex sink
strtk::parse(data, "|", hex_sink, p.name, p.age, p.height, p.weight);
                       </pre>


                       <p align="left">
                        Batch processing of a text file comprised of one person tuple per-line
                        is somewhat similar to the previous example. A predicate is defined
                        that takes a container specialized on the person struct, and a
                        delimiter predicate with which the <b>strtk::parse</b> function will be
                        invoked. This predicate is then instantiated and coupled with the text
                        file name, is fed to the <b>strtk::for_each_line</b> processor.
                       </p>

                       <pre>
template &lt;typename Container, typename Predicate&gt;
struct parse_person_tuple
{
public:

   parse_person_tuple(Container&amp; container)
   : container_(container),
     hex_sink(p_.id)
   {}

   void operator() (const std::string&amp; s)
   {
      if (strtk::parse(s, "|", hex_sink, p_.name, p_.age, p_.height, p_.weight))
         container_.push_back(p_);
      else
         std::cerr &lt;&lt; "Failed to parse: " &lt;&lt; s &lt;&lt; std::endl;
   }

private:

   Container&amp; container_;
   person p_;
   strtk::hex_to_number_sink&lt;unsigned int&gt; hex_sink;
};
                       </pre>


                       <p align="left">
                        Bringing the above pieces together to process a file results in the following:
                       </p>

                       <pre>
int main()
{
   std::string text_file_name = "person_records.txt";

   std::deque&lt;person&gt; person_list;

   strtk::for_each_line(file_name,predicate_type(person_list));

   return 0;
}
                       </pre>


                       <p align="left">
                        Before we continue on with the example, a re-written version
                        of the above code using C++11 lambdas is as follows:
                       </p>

                       <pre>
int main()
{
   std::string text_file_name = "person_records.txt";

   std::deque&lt;person&gt; person_list;

   person p;

   strtk::hex_to_number_sink&lt;unsigned int&gt; hex_sink;

   strtk::for_each_line(text_file_name,
                        [&amp;](const std::string&amp; line)
                        {
                           if (strtk::parse(line, "|", hex_sink, p.name, p.age, p.height, p.weight))
                              container_.push_back(p);
                           else
                              std::cerr &lt;&lt; "Failed to parse: " &lt;&lt; line &lt;&lt; std::endl;
                        });

   return 0;
}
                       </pre>

                       <p align="left">
                        To make things easier one could adapt a struct <em>(made up entirely of
                        PODs)</em> to a parser. This makes the usage syntax little easier to
                        follow. An example of this adaption is as follows:
                       </p>

                       <pre>
struct type
{
   std::string s;
   double d;
   int i;
   char c;
   bool b;
};

strtk_parse_begin(type)
 strtk_parse_type(s)
 strtk_parse_type(d)
 strtk_parse_type(i)
 strtk_parse_type(c)
 strtk_parse_type(b)
strtk_parse_end()

int main()
{
   type t;

   std::string s = "abcdefghijklmnop|123.456|987654321|A|1";

   strtk::parse(s, "|", t);

   return 0;
}
                       </pre>

                       <p align="left">
                        Another similar example to the previous, would be parsing a text file
                        of 3D coordinates into a sequence. This can be done easily and cleanly
                        using lambdas and StrTk as follows:
                       </p>

                       <pre>
struct point
{
   double x,y,z;
};

int main()
{
   std::string point_data = "point_data.txt";

   std::deque&lt;point&gt; points;

   point p;

   strtk::for_each_line(point_data,
                        [&amp;](const std::string&amp; str)
                        {
                           if (strtk::parse(str, ",", p.x, p.y, p.z))
                              points.push_back(p);
                        });
   return 0;
}
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="SimpleDateTimeParser">Simple Date-Time Parser</a></h3>
                       <p align="left">
                        Assuming the datetime struct defined below, and a string
                        representation of a combined date and time in the form of YYYY-MM-DD
                        HH:MM:SS.MS eg: <b>2005-06-26 15:57:03.678</b>
                       </p>

                       <pre>
struct datetime
{
   unsigned int year;
   unsigned int month;
   unsigned int day;
   unsigned int hour;
   unsigned int minute;
   unsigned int second;
   unsigned int msecond;
};
                       </pre>

                       <p align="left">
                        The following assumes an input of date-time values separated by a
                        pipe. To facilitate parsing of a date-time by the strtk::parse routine
                        into an STL compatible sequence an implementation of
                        string_to_type_converter_impl specific to the datetime type is
                        required. The following demonstrates how such a routine can be
                        generated and used within the strtk::parse context:
                       </p>

                       <pre>
strtk_string_to_type_begin(datetime)
   static const std::string delimiters ("-:. ");

   return strtk::parse(begin, end, delimiters,
                       t.year, t.month,  t.day,
                       t.hour, t.minute, t.second, t.msecond);
strtk_string_to_type_end()
                       </pre>

                       <p align="left">
                        A simple example of using strtk::parse in conjunction with the newly
                        integrated datetime variable mixed with variables of other types is as
                        follows:
                       </p>

                       <pre>
int main()
{
   const std::string data = "abc 123 xyz,2000-01-10 03:01:16.123|+98765.43210";

   std::string var0;
   datetime var1;
   double var2;

   strtk::parse(data, ",|", var0, var1, var2);

   return 0;
}
                       </pre>

                       <p align="left">
                        Bringing the above pieces together, in the following we can then
                        proceed to parse a sequence of date-time strings delimited by pipe "|"
                        into a deque of type datetime.
                       </p>

                       <pre>
int main()
{
   static const std::string data = "2000-01-10 03:01:16.123|2001-02-22 05:12:24.234|"
                                   "2002-03-13 07:23:32.345|2003-04-24 09:34:47.456|"
                                   "2004-05-15 11:46:51.767|2005-06-26 15:57:03.678|"
                                   "2006-07-17 17:45:31.561|2007-08-26 19:06:02.809|"
                                   "2008-09-18 21:16:23.267|2009-10-26 23:12:03.798|"
                                   "2010-11-23 13:47:11.963|2011-12-26 15:35:08.168";

   std::deque&lt;datetime&gt; datetime_list;

   strtk::parse(data,"|",datetime_list);

   for (std::size_t i = 0; i &lt; datetime_list.size(); ++i)
   {
      datetime&amp; dt = datetime_list[i];

      std::cout &lt;&lt; dt.year &lt;&lt; "-"
                &lt;&lt; strtk::text::right_align(2,'0',  dt.month) &lt;&lt; "-"
                &lt;&lt; strtk::text::right_align(2,'0',    dt.day) &lt;&lt; " "
                &lt;&lt; strtk::text::right_align(2,'0',   dt.hour) &lt;&lt; ":"
                &lt;&lt; strtk::text::right_align(2,'0', dt.minute) &lt;&lt; ":"
                &lt;&lt; strtk::text::right_align(2,'0', dt.second) &lt;&lt; "."
                &lt;&lt; strtk::text::right_align(3,'0',dt.msecond) &lt;&lt; std::endl;
   }

   return 0;
}
                       </pre>

                       <p align="left">
                        As a side note, the more commonly used date, time and date-time
                        formats can be easily parsed with a simple utilities library based on
                        StrTk called <a href="http://www.partow.net/programming/datetime/index.html">Datetime_Utils</a>.
                        The library makes use of the technique described above in conjunction
                        with the <b>strtk::offset_splitter</b> to provide efficient and high
                        performance parsers for formats such as the ones denoted below:
                       </p>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 13px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 13px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-hgcj{font-weight:bold;text-align:center}
                       .tg .tg-mejs{color:#000000;vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr> <th class="tg-hgcj">Format</th> <th class="tg-hgcj">Example</th> </tr>
                         <tr> <td class="tg-mejs">YYYYMMDD<br>             </td> <td class="tg-mejs">20060304<br>             </td> </tr>
                         <tr> <td class="tg-mejs">YYYYDDMM<br>             </td> <td class="tg-mejs">20060403<br>             </td> </tr>
                         <tr> <td class="tg-mejs">YYYY/MM/DD<br>           </td> <td class="tg-mejs">2006/03/04<br>           </td> </tr>
                         <tr> <td class="tg-mejs">YYYY/DD/MM<br>           </td> <td class="tg-mejs">2006/04/03<br>           </td> </tr>
                         <tr> <td class="tg-mejs">DD/MM/YYYY<br>           </td> <td class="tg-mejs">04/03/2006<br>           </td> </tr>
                         <tr> <td class="tg-mejs">HH:MM:SS.mss<br>         </td> <td class="tg-mejs">13:27:54.123<br>         </td> </tr>
                         <tr> <td class="tg-mejs">HH:MM:SS<br>             </td> <td class="tg-mejs">13:27:54<br>             </td> </tr>
                         <tr> <td class="tg-mejs">YYYYMMDD HH:MM:SS.mss<br></td> <td class="tg-mejs">20060304 13:27:54.123<br></td> </tr>
                         <tr> <td class="tg-mejs">YYYY/MM/DD HH:MM:SS.mss  </td> <td class="tg-mejs">2006/03/04 13:27:54.123  </td> </tr>
                         <tr> <td class="tg-mejs">DD/MM/YYYY HH:MM:SS.mss  </td> <td class="tg-mejs">04/03/2006 13:27:54.123  </td> </tr>
                         <tr> <td class="tg-mejs">YYYYMMDD HH:MM:SS<br>    </td> <td class="tg-mejs">20060304 13:27:54<br>    </td> </tr>
                         <tr> <td class="tg-mejs">YYYY/MM/DD HH:MM:SS<br>  </td> <td class="tg-mejs">2006/03/04 13:27:54<br>  </td> </tr>
                         <tr> <td class="tg-mejs">DD/MM/YYYY HH:MM:SS<br>  </td> <td class="tg-mejs">04/03/2006 13:27:54<br>  </td> </tr>
                         <tr> <td class="tg-mejs">YYYY-MM-DD HH:MM:SS.mss  </td> <td class="tg-mejs">2006-03-04 13:27:54.123  </td> </tr>
                         <tr> <td class="tg-mejs">DD-MM-YYYY HH:MM:SS<br>  </td> <td class="tg-mejs">04-03-2006 13:27:54<br>  </td> </tr>
                         <tr> <td class="tg-mejs">YYYY-MM-DDTHH:MM:SS<br>  </td> <td class="tg-mejs">2006-03-04T13:27:54<br>  </td> </tr>
                         <tr> <td class="tg-mejs">YYYY-MM-DDTHH:MM:SS.mss  </td> <td class="tg-mejs">2006-03-04T13:27:54.123  </td> </tr>
                         <tr> <td class="tg-mejs">YYYYMMDDTHH:MM:SS<br>    </td> <td class="tg-mejs">20060304T13:27:54<br>    </td> </tr>
                         <tr> <td class="tg-mejs">YYYYMMDDTHH:MM:SS.mss<br></td> <td class="tg-mejs">20060304T13:27:54.123    </td> </tr>
                       </tbody></table>



                       <p align="left">
                        In the following simple example we have an array of data representing tuples of trade
                        executions in CSV format. The objective is to populate the <b>trade_list</b> instance
                        with the given data via the defined trade struct. In the example the <b>dt_utils::datetime_format6</b>
                        date-time parser is used, it populates a general date-time type instance called
                        <b>dt_utils::datetime</b>. If the parse operation succeeds, then the date-time
                        components the trade type requires are updated and the instance itself is subsequently
                        added to the trade_list.
                       </p>

                       <pre>
struct trade
{
   std::string ticker;
   double price;
   unsigned int volume;
   unsigned short hr,min,sec,ms;
};

int main()
{
   std::string trade_data[] =
                 {
                    "2006-03-04 13:27:54.123,ABC,12.347,6676",
                    "2006-03-04 13:27:54.231,XYZ,23.455,71547",
                    "2006-03-04 13:27:54.312,IJK,34.562,514",
                    "2006-03-04 13:27:55.263,PQR,67.893,5949",
                    "2006-03-04 13:27:55.327,ABC,78.963,19",
                    "2006-03-04 13:27:55.524,XYZ,45.677,1276",
                    "2006-03-04 13:27:56.623,IJK,36.182,6676",
                    "2006-03-04 13:27:56.877,PQR,62.339,1547"
                 };

   std::deque&lt;trade&gt; trade_list;
   trade t;
   dt_utils::datetime dt;
   dt_utils::datetime_format6 dt6(dt);

   for (std::size_t i = 0; i &lt; sizeof(trade_data) / sizeof(std::string); ++i)
   {
      bool result =
         strtk::parse(trade_data[i], ",",
                      dt6, t.ticker, t.price, t.volume);
      if (result)
      {
         t.hr  = td.hour;
         t.min = td.minute;
         t.sec = td.second;
         t.ms  = td.millisecond;
         trade_list.push_back(t);
      }
   }

   return 0;
}
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="ParsingSubLists">Parsing Sub-Lists</a></h3>
                       <p align="left">
                        So far the demonstrated capabilities of the <b>strtk::parse</b> function
                        has been based on passing a series of parameters that are populated in a
                        linear fashion as the parser processes the tokens it encounters. That
                        said, some formats have their own sub-structures, a simple example
                        would be a list of values <em>(such as integers)</em> that need to be
                        loaded into a deque or stack. StrTk provides a series of sink facilities
                        that consume a range and an STL container which can be forwarded onto
                        <b>strtk::parse</b>.
                       </p>

                       <p align="left">
                        In the following example, the data string is comprised of 3 separate
                        lists delimited by a pipe "|". An integer, a string and a double type
                        list. Each list is to be parsed into an STL container of appropriate
                        type. In this case a vector, a deque and a list. StrTk provides the
                        ability to instantiate a sink for the specific container type that is
                        compatible with strtk::parse.
                       </p>

                       <pre>
int main()
{
   std::string data = "1,+2,-3,4|abc,ijk,rst,xyz|123.456,+234.567,-345.678,456.789,567.890";

   // Define containers
   std::vector&lt;int&gt; int_vector;
   std::deque&lt;std::string&gt; string_deque;
   std::list&lt;double&gt; double_list;
   std::set&lt;int&gt; int_set;
   std::queue&lt;std::string&gt; string_queue;
   std::stack&lt;double&gt; double_stack;
   std::priority_queue&lt;int&gt; int_priority_queue;

   // Define sinks
   strtk::vector_sink&lt;int&gt;::type         vec_sink(",");
   strtk::deque_sink&lt;std::string&gt;::type  deq_sink(",");
   strtk::list_sink&lt;double&gt;::type        lst_sink(",");
   strtk::set_sink&lt;int&gt;::type            set_sink(",");
   strtk::queue_sink&lt;std::string&gt;::type  que_sink(",");
   strtk::stack_sink&lt;double&gt;::type       stk_sink(",");
   strtk::priority_queue_sink&lt;int&gt;::type prq_sink(",");


   strtk::parse(data, "|", vec_sink(  int_vector),
                           deq_sink(string_deque),
                           lst_sink( double_list));

   strtk::parse(data, "|", set_sink(           int_set),
                           que_sink(      string_queue),
                           stk_sink(      double_stack),
                           prq_sink(int_priority_queue));

   return 0;
}
                       </pre>

                       <p align="left">
                        If only a certain number of elements in the list are required, for
                        example only the first 3, then the element count on the sink can be
                        set appropriately. The above example could be modified as follows:
                       </p>

                       <pre>
int main()
{
   std::string data = "1,+2,-3,4|string0|abc,ijk,rst,xyz|"
                      "string1|123.456,+234.567,-345.678,456.789,567.890";

   std::vector&lt;int&gt;        int_vector;
   std::deque&lt;std::string&gt; string_deque;
   std::list&lt;double&gt;       double_list;

   strtk::vector_sink&lt;int&gt;::type        vec_sink(",");
   strtk::deque_sink&lt;std::string&gt;::type deq_sink(",");
   strtk::list_sink&lt;double&gt;::type       lst_sink(",");

   std::string string_0;
   std::string string_1;

   strtk::parse(data, "|", vec_sink(  int_vector).count(2),  // Consume first 2 values
                           string_0,
                           deq_sink(string_deque).count(3),  // Consume first 3 values
                           string_1,
                           lst_sink( double_list).count(4)); // Consume first 4 values
   return 0;
}
                       </pre>

                       <p align="left">
                        <b>Note:</b> If there aren't enough elements in a particular list, then
                        parsing of that list fails and subsequently the call to strtk::parse
                        will fail.
                       </p>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="ParsingTrailingLists">Parsing Trailing-Lists</a></h3>
                       <p align="left">
                        Another way one might want to parse a tuple of values might be to
                        parse a prefix of values into a specific number of possibly varying
                        types, then to parse the remaining values <em>(assuming they are all
                        of the same type)</em> into a sequence or list etc. StrTk provides the
                        following simple solution to the given problem, as demonstrated below:
                       </p>

                       <pre>
int main()
{
   {
      std::string data = "A String Value,111.111,222.222,333.333,444.444,555.555";
      std::string token;
      std::vector&lt;double&gt; double_list;
      strtk::parse(data, ",", token, double_list);
   }

   {
      std::string data = "A String Value,01-02-2003,111.111,222.222,333.333,444.444,555.555";
      std::string token;
      std::string date;
      std::deque&lt;double&gt; double_list;
      strtk::parse(data, ",", token, date, double_list);
   }

   {
      std::string data = "A String Value,01-02-2003,123456789,111.111,"
                         "222.222,333.333,444.444,555.555";
      std::string token;
      std::string date;
      int i;
      std::list&lt;double&gt; double_list;
      strtk::parse(data, ",", token, date, i, double_list);
   }

   {
      std::string data = "A String Value,01-02-2003,123456789,111.111,"
                         "222.222,333.333,444.444,555.555";
      std::string token;
      std::string date;
      int i;
      double d;
      std::vector&lt;double&gt; double_list;
      strtk::parse(data, ",", token, date, i, d, double_list);
   }

   {
      std::string data = "A String Value,01-02-2003,123456789,111.111,"
                         "222.222,333.333,444.444,555.555";
      std::string token;
      std::string date;
      int i;
      double d1;
      double d2;
      std::deque&lt;double&gt; double_list;
      strtk::parse(data, ",", token, date, i, d1, d2, double_list);
   }

   return 0;
}
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="ExtendingTheDateTimeParserExample">Extending The Date-Time Parser Example</a></h3>
                       <p align="left">
                        Building upon the previous datetime example, We are presented with a
                        tuple of data that represents an astronomical event. The event defines
                        a name, a location and a series of date-times in UTC the event was
                        observed. In order to construct the necessary sink(s) that will be
                        used for parsing the required type into a container, the macro
                        <b>strtk_register_userdef_type_sink</b> with the specified type is
                        invoked. The following is a definition of the struct one might construct:
                       </p>

                       <pre>
struct event_information
{
   std::size_t id;
   std::string name;
   std::string location;
   std::deque&lt;datetime&gt; observation_datetimes;
};

strtk_register_userdef_type_sink(datetime)
                       </pre>

                       <p align="left">
                        Bringing the above together with a call to <b>strtk::parse</b> results
                        in the following code which parses the event data tuple into the allocated
                        event_information instance.
                       </p>

                       <pre>
int main()
{
   std::string event_data = "172493|Lunar Impact|Mare Tranquillitatis|"
                            "2010-01-19 00:28:45.357,2010-02-18 00:57:07.109,"
                            "2010-03-20 01:15:11.261,2010-04-21 01:07:27.972";

   strtk::deque_sink&lt;datetime&gt;::type deq_sink(",");

   event_information evt_info;

   strtk::parse(event_data, "|", evt_info.id,
                                 evt_info.name,
                                 evt_info.location,
                                 deq_sink(evt_info.observation_datetimes));
   return 0;
}
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="TokenProcessingDuringParsing">Token Processing During Parsing</a></h3>
                       <p align="left">
                        StrTk offers a set of convenient and simple to use token processing
                        primitives that can be invoked during a call to the strtk::parse
                        routine to perform various actions upon the tokens being parsed. These
                        actions include such things as modifications and validations of
                        tokens.
                       </p>

                       <p align="left">
                        The following is a list of token processing primitives used for
                        constraint and verification purposes: <br>

                        </p><ul style="text-align: left">
                        <li>strtk::ignore_token</li>
                        <li>strtk::expect      </li>
                        <li>strtk::iexpect     </li>
                        <li>strtk::like        </li>
                        <li>strtk::inrange     </li>
                        </ul>

                        The following is a list of token processing primitives used for
                        modifying and normalising purposes:

                        <ul style="text-align: left">
                        <li>strtk::trim         </li>
                        <li>strtk::trim_leading </li>
                        <li>strtk::trim_trailing</li>
                        <li>strtk::as_lcase     </li>
                        <li>strtk::as_ucase     </li>
                        </ul>

                        The primitives all return either a true or false value upon parsing
                        completion, which is then further used by the strtk::parse routine
                        to determine if the parse operation as a whole has succeeded or failed.
                       <p></p>

                       <h3 align="left"><a name="IgnoreTokenProcessing">Ignore Token Processing</a></h3>
                       <p align="left">
                        There may be scenarios when given a delimited tuple of data, that one
                        or more of the tokens need to be ignored or skipped. StrTk provides a
                        mechanism called strtk::ignore_token that allows the parser to consume
                        specific tokens easily without affecting overall performance. Below is
                        an example of how strtk::ignore_token can be used in conjunction with
                        strtk::parse to skip the 2nd and 4th tokens in the tuple:
                       </p>

                       <pre>
int main()
{
   static const std::string data = "+123,ignore0,123.456,ignore1,abcdef,ignore2";

   int i;
   double d;
   std::string s;

   strtk::ignore_token ignore;

   strtk::parse(data, ",", i, ignore, d, ignore, s);

   std::cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; std::endl;
   std::cout &lt;&lt; "d = " &lt;&lt; d &lt;&lt; std::endl;
   std::cout &lt;&lt; "s = " &lt;&lt; s &lt;&lt; std::endl;

   return 0;
}
                       </pre>

                       <h3 align="left"><a name="ExpectAndIExpectTokenProcessing">Expect And IExpect Token Processing</a></h3>
                       <p align="left">
                        When parsing a tuple, one may want to ensure that specific tokens of
                        the tuple are of a certain string value. StrTk provides this type of
                        functionality via the strtk::expect and <b>strtk::iexpect</b> mechanisms.
                        The <b>strtk::expect</b> form enforces an exact string match, whereas
                        the <b>strtk::iexpect</b> enforces only a case-insensitive match. The
                        following is an example where we attempt to parse a 'pascal-like' variable
                        declaration and definition. The requirement is that the first token be
                        "var" followed by a variable name and then a type name of 'Integer'
                        which is not case sensitive.
                       </p>

                       <pre>
int main()
{
   static const std::string data = "var foo : InTeGeR = 3;";

   std::string variable_name;
   int initial_value;

   bool result = strtk::parse(data,
                              " ;",
                              strtk::expect("var").ref(),
                              variable_name,
                              strtk::expect(":").ref(),
                              strtk::iexpect("Integer").ref(),
                              strtk::expect("=").ref(),
                              initial_value);

   if (result)
      std::cout &lt;&lt; variable_name &lt;&lt; " = " &lt;&lt; initial_value &lt;&lt; std::endl;
   else
     std::cout &lt;&lt; "Failed to parse statement!" &lt;&lt; std::endl;

   return 0;
}
                       </pre>

                       <h3 align="left"><a name="LikeTokenProcessing">Like Token Processing</a></h3>
                       <p align="left">
                        Similar to the above mentioned strtk::expect and strtk::iexpect
                        primitives, StrTk provides a simple wildcard matching of tokens
                        functionality via the <b>strtk::like</b> mechanism. The special
                        characters of '*' and '?' are used denoting 'zero or more' and
                        'zero or one' match modes respectively. The following example
                        uses the strtk::like in conjunction with strtk::expect to parse
                        a tuple of key/value pairs.
                       </p>

                       <pre>
int main()
{
   static const std::string data = "token0=+123;token1=abc;token2=-456.678;";

   int i;
   std::string s;
   double d;

   strtk::parse(data,
                "=;",
                strtk::like("to*n?").ref(),
                i,
                strtk::like("token?").ref(),
                s,
                strtk::iexpect("tOkEn2").ref(),
                d);

   std::cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; std::endl;
   std::cout &lt;&lt; "s = " &lt;&lt; s &lt;&lt; std::endl;
   std::cout &lt;&lt; "d = " &lt;&lt; d &lt;&lt; std::endl;

   return 0;
}
                       </pre>


                       <h3 align="left"><a name="InRangeTokenProcessing">In-Range Token Processing</a></h3>
                       <p align="left">
                        When parsing tokens, one may wish to determine if the token when
                        viewed in its target type resides within a specified range [r0,r1]. As
                        the tokens can be of any type, not necessarily just string or
                        numerical in nature, the type must have a less- than comparable
                        attribute. The following example attempts to parse a key/value tuple
                        that contains a temperature and a name component.
                       </p>

                       <pre>
int main()
{
   static const std::string data = "temperature=+123.456;name=Rumpelstilzchen";

   double temperature;
   std::string name;

   strtk::parse(data,
                "=;",
                // Process temperature section
                strtk::expect("temperature").ref(),
                strtk::inrange(temperature, -432.1, +432.1).ref(),

                // Process name section
                strtk::expect("name").ref(),
                strtk::inrange(name, "AAAA", "zzzz").ref());

   std::cout &lt;&lt; "temperature = " &lt;&lt; temperature &lt;&lt; std::endl;
   std::cout &lt;&lt; "name = " &lt;&lt; name &lt;&lt; std::endl;

   return 0;
}
                       </pre>

                       <h3 align="left"><a name="TrimTokenProcessing">Trim Token Processing</a></h3>
                       <p align="left">
                        At times tokens within a tuple may have padding added to either the
                        left, right or both ends. When processing the token it maybe necessary
                        to remove the superfluous padding before attempting to convert the
                        string or range representation of the token into its target type(int,
                        double etc). The example below, demonstrates the use of various forms
                        of token trimming in conjunction strtk:parse.
                       </p>

                       <pre>
int main()
{
   {
      std::string data = "****abc123****,****abc123****,****abc123****";

      std::string s0;
      std::string s1;
      std::string s2;

      strtk::parse(data,",",
                   strtk::trim("*",s0).ref(),
                   strtk::trim_leading ("*",s1).ref(),
                   strtk::trim_trailing("*",s2).ref());

      std::cout &lt;&lt; "s0 = [" &lt;&lt; s0 &lt;&lt; "]" &lt;&lt; std::endl;
      std::cout &lt;&lt; "s1 = [" &lt;&lt; s1 &lt;&lt; "]" &lt;&lt; std::endl;
      std::cout &lt;&lt; "s2 = [" &lt;&lt; s2 &lt;&lt; "]" &lt;&lt; std::endl;

      // Expected Output:
      // s0 = [abc123]
      // s1 = [abc123****]
      // s2 = [****abc123]
   }

   {
      std::string data = "*?*?a string*?*?,*?*123456,123.456?*?*?";

      std::string s;
      int i;
      double d;

      strtk::parse(data,",",
                   strtk::trim("*?",s).ref(),
                   strtk::trim_leading ("?*",i).ref(),
                   strtk::trim_trailing("*?",d).ref());

      std::cout &lt;&lt; "s = [" &lt;&lt; s &lt;&lt; "]" &lt;&lt; std::endl;
      std::cout &lt;&lt; "i = [" &lt;&lt; i &lt;&lt; "]" &lt;&lt; std::endl;
      std::cout &lt;&lt; "d = [" &lt;&lt; d &lt;&lt; "]" &lt;&lt; std::endl;

      // Expected Output:
      // s = [a string]
      // i = [123456]
      // d = [123.456]
   }

   return 0;
}
                       </pre>

                       <h3 align="left"><a name="CaseNormalisationTokenProcessing">Case Normalisation Token Processing</a></h3>
                       <p align="left">
                        Another pair of token processing mechanisms provided by StrTk, are the
                        <b>strtk::as_lcase</b> and <b>strtk::as_ucase mechanisms</b>. They
                        convert the string representation of the token to lowercase and uppercase
                        characters respectively. The following example, parses a two token
                        tuple, and converts the first token s0 to all lowercase and the second
                        token s1 to all uppercase.
                       </p>

                       <pre>
int main()
{
   std::string data = "AbCd,EfGhI";

   std::string s0;
   std::string s1;

   strtk::parse(data,",",
                strtk::as_lcase(s0).ref(),
                strtk::as_ucase(s1).ref());

   std::cout &lt;&lt; "s0 = [" &lt;&lt; s0 &lt;&lt; "]" &lt;&lt; std::endl;
   std::cout &lt;&lt; "s1 = [" &lt;&lt; s1 &lt;&lt; "]" &lt;&lt; std::endl;

   // Expected Output:
   // s0 = [abcd]
   // s1 = [EFGHI]

   return 0;
}
                       </pre>


                       <h3 align="left"><a name="ParsingTruncatedValues">Parsing Truncated Values</a></h3>
                       <p align="left">
                        There may be times during parsing when a token which is intended to be
                        parsed as an integral type (eg: int, short, unsigned int et al) may be
                        represented using decimal notation (eg: 1234.00000).<br> <br>

                        Normally if the token were to be passed as-is it would cause a
                        conversion error due to the fact that there are invalid characters
                        within the token.<br> <br>

                        StrTk provides a facility called strtk::truncated_int that can be used
                        with both signed and unsigned integral types. The type truncated_int
                        is specialised with the required type, then an instance of the type is
                        registered with it either prior to or inline with the conversion/parse
                        call. When the conversion occurs strtk::truncated_int simply redefines
                        the end of the token range to be the decimal point <em>(if it is present)</em>
                        and then passes it along to the appropriate string_to_type_converter_impl
                        call.
                       </p>

                       <pre>
int main()
{
   {
      // Convert decimal representation to an int
      int i = 0;
      std::string data = "-1234.0000";
      strtk::truncated_int&lt;int&gt; ti;
      strtk::string_to_type_converter(data,ti(i));
   }

   {
      // Parse a tuple of decimal values into ints i0 and i1
      int i0 = 0;
      int i1 = 0;
      std::string data = "-1234.0000|456.7890";
      strtk::truncated_int&lt;int&gt; ti0;
      strtk::truncated_int&lt;int&gt; ti1;
      strtk::parse(data, "|", ti0(i0), ti1(i1));
   }
}
                       </pre>

                       <p align="left">
                        An optional parameter that can be utilized is the 'fractional_size'
                        which denotes the exact number of digits after the decimal place that
                        is expected. In the event this condition is not met a conversion error
                        is returned.
                       </p>

                       <pre>
int main()
{
   std::string data = "-1234.000";

   strtk::truncated_int&lt;int&gt; ti;

   ti.fractional_size(3);

   int i = 0;

   if (strtk::string_to_type_converter(data,ti(i)))
      std::cout &lt;&lt; "i: " &lt;&lt; i &lt;&lt; std::endl;
   else
      std::cout &lt;&lt; "Error parsing: " &lt;&lt; data &lt;&lt; std::endl;

   return 0;
}
                       </pre>

                       <p align="left">
                        In the following example, we have an array of trade execution tuples
                        in csv format. The tuple is comprised of the following fields: ticker
                        name (string), trade id (uint64 right aligned with space as padding),
                        execution price (double), executed volume (unsigned int with 4 decimal
                        place suffix). The struct trade will be used to store the tuples in
                        memory. The objective is to parse each tuple and populate the
                        trade_list structure with all the trades, noting any errors that occur
                        along the way.
                       </p>

                       <pre>struct trade
{
   unsigned long long id;
   std::string    ticker;
   double          price;
   unsigned int   volume;
};

int main()
{
   std::string trade_data[] =
               {
                 "AAA,   0,36.900,009352.0000",
                 "BBB,   1,46.000,009800.0000",
                 "CCC,   2,46.000,009400.0000",
                 "DDD,   3,46.000,001500.0000",
                 "AAA,   4,46.000,000600.0000",
                 "BBB,   5,46.000,039800.0000",
                 "CCC,   6,46.000,003200.0000",
                 "DDD,   7,46.000,000100.0000",
                 "AAA,   8,46.000,000800.0000",
                 "BBB,   9,48.500,002400.0000",
                 "CCC,  10,37.395,101200.0000",
                 "DDD,  11,37.193,200000.0000",
                 "AAA,  12,37.146,020000.0000",
                 "BBB,  13,38.314,001752.0000",
                 "CCC,  14,37.386,130000.0000",
                 "DDD,  15,37.443,100000.0000"
               };

   std::deque&lt;trade&gt; trade_list;

   strtk::truncated_int&lt;unsigned int&gt; tui;
   tui.fractional_size(4);

   for (std::size_t i = 0; i &lt; sizeof(trade_data) / sizeof(std::string); ++i)
   {
      trade t;

      bool result = strtk::parse(trade_data[i],",",
                                 t.ticker,
                                 strtk::trim_leading(" ",t.id).ref(),
                                 t.price,
                                 tui(t.volume));

     if (result)
        trade_list.push_back(t);
     else
        std::cout &lt;&lt; "Tuple parse error: " &lt;&lt; trade_data[i] &lt;&lt; std::endl;
   }

   return 0;
}
                       </pre>

                       <p align="left">
                        It should be noted that truncated_int can be used in conjunction
                        with the various StrTk token processing primitives such as strtk::trim,
                        <b>strtk::trim_leading</b>, strtk::as_lcase et al . The following
                        example demonstrates parsing a tuple of values intended for int types,
                        where the tokens have random space padding. The simple composition of
                        <b>strtk::truncated_int</b> and strtk::trim allows for efficient and
                        error free parsing of the tuple.
                       </p>

                       <pre>
int main()
{
   std::string data = "   123.0 |  456.00    | 789.000";

   int i0,i1,i2;

   strtk::truncated_int&lt;int&gt; ti0;
   strtk::truncated_int&lt;int&gt; ti1;
   strtk::truncated_int&lt;int&gt; ti2;

   strtk::parse(data,"|",
                strtk::trim(" ",ti0(i0)).ref(),
                strtk::trim(" ",ti1(i1)).ref(),
                strtk::trim(" ",ti2(i2)).ref());

   printf("i0 = [%d]  i1 = [%d]  i2 = [%d]\n",i0,i1,i2);
   // i0 = [123]  i1 = [456]  i2 = [789]

   return 0;
}
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="ColumnwiseParsing">Columnwise Parsing</a></h3>
                       <p align="left">
                        In the previous section the ability to ignore tokens in a tuple was
                        discussed. The concept works well if only a few tokens need to be
                        ignored. However problems arise when the tuples contain a large number
                        of tokens and the tokens that are to be ignored are numerous and
                        distributed uniformly over the entire tuple.<br> <br>

                        Situations such as this one are common, and using the ignore_token
                        technique can not only make both the coding of the solution cumbersome
                        and error prone but also make the parsing process itself quite<br> <br>
                        inefficient.

                        A natural extension to ignore_token that scales and is also extremely
                        efficient, can be found in the combined functionalities of the
                        parse_columns and column_list. The column_list is a structure used to
                        hold the indexes of the tokens in the tuple that are required. The
                        indexes have to be valid, unique and in ascending order.
                       </p>

                       <pre>
// Even indexes [0,12]
auto cl_even = strtk::column_list(0, 2, 4, 6, 8, 10, 12);

// Odd indexes [1,7]
auto cl_odd = strtk::column_list(1, 3, 5, 7);
                       </pre>

                       <p align="left">
                        The strtk::parse_columns function takes a string of data representing
                        a tuple, a delimiter to determine the tokens in the tuple, a
                        strkt::column_list and a compatible number of types as target
                        references.<br> <br>

                        The number of types has to be equal to the number of indexes in the
                        column_list, and the types need to be convertible within the strtk
                        namespace from a string range representation to the type. In the
                        following example we have a tuple consisting of integers. We're only
                        interested in the first four even numbered indexes in the tuple, the
                        code below demonstrates how the tuple is parsed with the given
                        constraints:
                       </p>

                       <pre>
int main()
{
   const std::string data = "1,22;333|4444 55555|666666;7777777,88888888 999;"
                            "0000|1111,22222,333333,4444444";

   int i0,i1,i2,i3,i4;

   strtk::parse_columns(data,
                        ",;| ",
                        strtk::column_list(0, 2, 4, 6, 8),
                        i0, i1, i2, i3, i4);
   return 0;
}
                       </pre>

                       <p align="left">
                        In the following example we have a tuple consisting of a mixture of
                        types. We are only interested in the first, fifth and eighth indexes
                        in the tuple, which happen to be of type int, double and std::string
                        respectively. The code below demonstrates how the tuple is parsed with
                        the given constraints:
                       </p>

                       <pre>
int main()
{
   const std::string data = "token0,1234;token2;token3,token4,11.22|token6;token7|"
                            "text-i-text,1 2 3 4 5 6 7";

   int i;
   double d;
   std::string s;

   strtk::parse_columns(data,
                        ",;| ",
                        strtk::column_list(1, 5, 8),
                        i, d, s);
   return 0;
}
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="Simple3DMeshFileFormatParser">Simple 3D Mesh File Format Parser</a></h3>
                       <p align="left">
                        Lets assume there is a file format for expressing a mesh. The format
                        consists of a section that defines the unique vertexes in the mesh,
                        and another section that defines the triangles in the mesh as a tuple
                        of three indicies indicating the vertexes used. Each section is
                        preceded by an integer that denotes the number of subsequent elements
                        in that section. An example of such a file is the following:
                       </p>

                       <pre>
5
+1.0,+1.0,+1.0
-1.0,+1.0,-1.0
-1.0,-1.0,+1.0
+1.0,-1.0,-1.0
+0.0,+0.0,+0.0
4
0,1,4
1,2,4
2,3,4
3,1,4
                       </pre>

                       <p align="left">
                        Code to parse such a file format is as follows:
                       </p>

                       <pre>struct point
{
   double x,y,z;
};

struct triangle
{
   std::size_t i0,i1,i2;
};

int main()
{
   std::string mesh_file = "mesh.txt";

   std::ifstream stream(mesh_file.c_str());

   std::string s;

   // Process points section
   std::deque&lt;point&gt; points;
   point p;
   std::size_t point_count = 0;
   strtk::parse_line(stream, " ", point_count);
   strtk::for_each_line_n(stream,
                          point_count,
                          [&amp;points,&amp;p](const std::string&amp; line)
                          {
                             if (strtk::parse(line, ",", p.x, p.y, p.z))
                                points.push_back(p);
                          });

   // Process triangles section
   std::deque&lt;triangle&gt; triangles;
   triangle t;
   std::size_t triangle_count = 0;
   strtk::parse_line(stream, " ", triangle_count);
   strtk::for_each_line_n(stream,
                          triangle_count,
                          [&amp;triangles,&amp;t](const std::string&amp; line)
                          {
                             if (strtk::parse(line, ",", t.i0, t.i1, t.i2))
                                triangles.push_back(t);
                          });

   return 0;
}

                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="Simple Semantic Actions">Simple Semantic Actions</a></h3>
                       <p align="left">
                        A semantic action is an action that is undertaken upon a token, it can
                        be in the form of either an assessment or a manipulation. StrTk
                        provides a very simplified semantic action capability, named
                        strtk::util::semantic_action for types that are being parsed via the
                        strtk::parse function. A function <em>(stateful or stateless)</em>,
                        taking an iterator range is used to construct the semantic_action.
                        The body of the function performs whatever operations are required
                        and also makes sure to maintain the contract with regards to the
                        return status for the parse routine to complete successfully.<br><br>

                        The following is an example where a comma delimited string is parsed
                        into 3 types, an integer, a double and a string. The rules regarding
                        parsing and updating of the variables is as follows, the int variable
                        "i" will only be updated if the value parsed is odd, the double value
                        "d" will only be updated if the parsed value is greater than or equal
                        to 99.99 and the string value "s" will only be updated if the presented
                        range contains the string "ring". Upon every successful update a
                        corresponding counter will be incremented.
                       </p>

                       <pre>
int main()
{
   std::string data = "12345,123.456,A string";
   int i = 0;
   double d = 0.0;
   std::string s = "";
   std::size_t i_update_count = 0;
   std::size_t d_update_count = 0;
   std::size_t s_update_count = 0;

   typedef strtk::range::ustring::const_iterator itr_type;
   using strtk::util::semantic_action;

   strtk::parse(data,",",
                // Token_0 (i) - Parse and update if value is odd
                semantic_action([&amp;i, &amp;i_update_count]
                                (itr_type begin, itr_type end) -&gt; bool
                                {
                                   int temp = 0;

                                   if (strtk::string_to_type_converter(begin, end, temp))
                                   {
                                      if (temp % 2 != 0)
                                      {
                                         i = temp;
                                         ++i_update_count;
                                      }
                                      return true;
                                   }
                                   else
                                      return false;

                                }).ref(),

                // Token_1 (d) - Parse and update if value is greater than 99.99
                semantic_action([&amp;d, &amp;d_update_count]
                                (itr_type begin, itr_type end) -&gt; bool
                                {
                                   double temp = 0.0;

                                   if (strtk::string_to_type_converter(begin, end, temp))
                                   {
                                      if (temp &gt;= 99.99)
                                      {
                                         d = temp;
                                         ++d_update_count;
                                      }

                                      return true;
                                   }
                                   else
                                      return false;

                                }).ref(),

                // Token_2 (s) - Parse and update if value contains "ring"
                semantic_action([&amp;s, &amp;s_update_count]
                                (itr_type begin, itr_type end) -&gt; bool
                                {
                                   static unsigned char pattern[] = "ring";

                                   if (end != std::search(begin, end, pattern, pattern + 4))
                                   {
                                      s.assign(begin,end);
                                      ++s_update_count;
                                   }

                                   return true;

                                }).ref());

   std::cout &lt;&lt; "i: " &lt;&lt; i &lt;&lt; std::endl;
   std::cout &lt;&lt; "d: " &lt;&lt; d &lt;&lt; std::endl;
   std::cout &lt;&lt; "s: " &lt;&lt; s &lt;&lt; std::endl;

   return 0;
}
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="PickARandomLineFromATextFile">Pick A Random Line From A Text File</a></h3>
                       <p align="left">
                        A random line of text is to be selected from a user provided text file
                        comprised of lines of varying length, such that the probability of the
                        line being selected is 1/N where N is the number of lines in the text
                        file. There are many trivial solutions to this problem, however if one
                        were to further constrain the problem by indicating the file is very
                        large (TBs) and that the system upon which the solution is to run is
                        very limited memory-wise, most if not all trivial solutions such as
                        storing indexes of all line offsets, or reading the entire file into
                        memory etc will be eliminated.<br> <br>

                        However, there exists a very elegant solution to this problem of O(n),
                        O(1) time and space complexities respectively, that involves scanning
                        the entire file once line by line, and at every ith line choosing
                        whether or not to replace the final result line with the current line
                        by sampling a uniform distribution of range [0,1) and performing a
                        replace if and only if the random value is less than 1 / i.
                       </p>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_line_probability_diagram.png" alt="C++ String Toolkit Library Reservoir Sampling - Copyright Arash Partow" border="0">
                       </p>

                       <p align="left">
                        The logic behind this solution revolves around the fact that the
                        probability of selecting the ith line will be 1/i and as such the
                        total probability for selecting any of the previous i-1 lines will be
                        1 - (1/i) or (i - 1)/i. Because there are (i - 1) lines before the ith
                        line, we divide the previous sum of probabilities by (i - 1),
                        resulting in a selection probability of 1/i for any one of the lines
                        up to and including the ith line. If the ith line were to be the last
                        line of the text file, this then results in each of the lines having a
                        selection probability of 1/N - simple and sweet, and so too is the
                        following implementation of said solution:
                       </p>


                       <pre>int main(int argc, char* argv[])
{
   std::string file_name = argv[1];
   std::string line;

   std::size_t i = 0;

   strtk::uniform_real_rng rng(static_cast<std::size_t>(::time(0)));

   strtk::for_each_line(file_name,
                        [&amp;](const std::string&amp; s)
                        {
                           if (rng() &lt; (1.0 / ++i))
                           {
                              line = s;
                           }
                        });

   std::cout &lt;&lt; line &lt;&lt; std::endl;

   return 0;
}
                       </std::size_t></pre>

                       <p align="left">
                        What changes to the above code would be required If the probability of
                        line selection was changed to 1/(N - K) where 0 &lt;= K &lt;= N and K is the
                        number of lines that will be randomly ignored.<br> <br>

                        <b>Note:</b> TAOCP Volume II section 3.4.2 has an in depth discussion
                        about this problem, which is generally known as <a href="http://en.wikipedia.org/wiki/Reservoir_sampling">reservoir sampling</a>,
                        and other similar problems relating to random distributions. Also one
                        should note that the above example has an inefficiency, in that upon
                        every string replace, an actual string is being copied, normally all
                        one needs to do is maintain a file offset to the beginning of the
                        line, not doing this causes slow downs due to continuous memory
                        allocations/reallocations which is made all the worse when large lines
                        are encountered.
                       </p>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="TheBuyLowAndSellHighProblem">The Buy Low And Sell High Problem</a></h3>
                       <p align="left">
                        Assume we are given a piece of data in csv format which represents a
                        time-series for the close prices of the <a href="http://en.wikipedia.org/wiki/SPDR">SPDR S&amp;P 500 ETF</a>.
                        The time-series ranges from 04/01/1999 to 11/11/2011. The objective
                        is to select two dates, the first being the buy date and the second being
                        the sell date, such that if we were to buy then sell X shares of the
                        ETF we will have maximized our profit. It should be noted that of course
                        the buy date must be before the sell date and that short selling is not
                        an option in this strategy. The following is a chart that represents the
                        price of the SPDR over the given period:
                       </p>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_spdr_chart.png" alt="C++ String Toolkit Library SPDR ETF - Copyright Arash Partow" border="0">
                       </p>

                       <p align="left">
                        Through visual inspection we can approximate that the best buy date
                        would be towards the end of 2002 and the corresponding sell date would
                        be towards the end of 2007, as these time points seem to give the
                        largest difference between the two prices. However it also seems that
                        a buy roughly at the start of 2009 and a sell at the beginning of 2011
                        could also provide such a large price difference. As such the visual
                        inspection approach has lead to an ambiguity, hence a more thorough
                        and precise approach is required.<br> <br>

                        One could take the naive approach to solving the buy low sell high
                        problem, by initially loading the entire time series into memory, then
                        for each ith time point take the pricei and test it against every
                        other pricej wherei &lt; j, and maintain a "best profit encountered"
                        structure that contains the best profit so far and the corresponding
                        buy/sell prices and dates. This solution has a few problems, initially
                        it is of O(N<sup>2</sup>) time complexity and O(N) space complexity.
                        As an example for one million time points it will require one trillion
                        comparisons and one million date/price units of storage. If memory and
                        computational processing was limited on the hardware this solution can
                        not be practically executed in a continuous online manner. Furthermore
                        as suggested by the time -complexity as the size of the data grows,
                        regardless of computational abilities, the compute times for the
                        results would become astronomical and practically useless - specially
                        for real-time reactive systems.<br> <br>

                        In these types of problems one tries to assess if an online or
                        streaming based solution is feasible. That is a solution that does not
                        require the data to be available all at once, can work on the data
                        incrementally and requires no more than one-pass for each piece of
                        data. Such a solution would typically have a time complexity of O(N)
                        and a space complexity of O(1).<br> <br>

                        With regards to this problem the crucial insight required to convert
                        the naive solution from O(N<sup>2</sup>) complexity to an online version
                        of O(N) time complexity, is that every new global minima encountered
                        is the beginning of a new period and an indicator of an end to the previous
                        period. Looking at the chart, if one were to scan from left to right,
                        the intuitive response is to find the point with the lowest price,
                        ignore everything preceding, then try and find the next point with the
                        highest price or global maxima. There are a few edge cases that need
                        to be dealt with. The main one being the problem described above that
                        there are two buy/sell points that could potentially be the solution.
                        The way around this is to simply maintain the best encountered period,
                        and compare the profit from any new period to the best so far, if it
                        is better <em>(more)</em> then replace the best with the current period.
                        Another edge case is when the data is in a continual decline, in a
                        situation like this there will be no profitable buy/sell points. The
                        following is a small subsection of the time-series in question:<br> <br>

                        <a href="http://www.partow.net/programming/strtk/data/spy500.zip">Download spy500.csv</a><br>

                       </p>

                       <pre>
15/06/2000,148.16
16/06/2000,146.59
19/06/2000,148.47
20/06/2000,147.94
21/06/2000,147.88
22/06/2000,145.63
23/06/2000,144.38
26/06/2000,146.23
27/06/2000,145.16
28/06/2000,145.56
29/06/2000,144.19
                       </pre>

                       <p align="left">
                        The code below is a very simple single pass incremental solution to
                        the given problem. It reads every line of the input file, parses each
                        line into a date and price variable, checks to see if the current
                        price is less than the current global minima price, if it is the case,
                        it will set the current period start to the current date and set the
                        buy price to be the current price, otherwise it checks to see if the
                        current price is larger than the global maxima price, if that is the
                        case then it updates the current profit, sell price and sell dates
                        accordingly. If at the end, the buy price is not less than the sell
                        price, it is indicative that there exists no two time points within
                        the given time series for which a profitable transaction could occur,
                        otherwise it prints out buy and sell dates for the required
                        transaction and the expected profit per share.
                       </p>

                       <pre>
struct period
{
   period()
   : profit    (std::numeric_limits&lt;double&gt;::min()),
     buy_price (std::numeric_limits&lt;double&gt;::max()),
     sell_price(std::numeric_limits&lt;double&gt;::min())
   {}

   double profit;
   double buy_price;
   double sell_price;
   std::string buy_date;
   std::string sell_date;
};

int main()
{
   period best_period;
   period curr_period;

   strtk::for_each_line(
      "spy500.csv",
      [&amp;best_period,&amp;curr_period]
      (const std::string&amp; line)
      {
         std::string date;
         double price;

         if (!strtk::parse(line, ",", date, price)) return;

         if (price &lt; curr_period.buy_price)
         {
            if (curr_period.proft &gt; best_period.profit)
            {
               best_period = curr_period;
            }

            curr_period.buy_date   = date;
            curr_period.buy_price  = price;
            curr_period.sell_price = std::numeric_limits&lt;double&gt;::min();
            curr_period.sell_date  = "";
         }
         else if (price &gt; curr_period.sell_price)
         {
            curr_period.sell_price = price;
            curr_period.sell_date  = date;
            curr_period.profit     = curr_period.sell_price - curr_period.buy_price;
         }
      });

   if (best_period.buy_price &gt;= best_period.sell_price)
   {
      std::cout &lt;&lt; "No period in the time-series can be profitably exploited." &lt;&lt; std::endl;
   }
   else
   {
      std::cout &lt;&lt; "Buy:    " &lt;&lt; best_period.buy_date  &lt;&lt; std::endl;
      std::cout &lt;&lt; "Sell:   " &lt;&lt; best_period.sell_date &lt;&lt; std::endl;
      std::cout &lt;&lt; "Profit per share: $" &lt;&lt; best_period.profit &lt;&lt; std::endl;
   }

   return 0;
}
                       </pre>

                       <p align="left">
                        For the given data it is expected the above piece of
                        code will produce the following output:
                       </p>

                       <pre>
Buy:    09/10/2002
Sell:   09/10/2007
Profit per share: $78.38
                       </pre>

                       <p align="left">
                       <b>Quick Quiz:</b> What changes to the above piece of code would be required if:<br>
                       </p><ul style="text-align: left">
                       <li>Rather than prices, we instead are given percentage differences from the previous price?                                                    </li>
                       <li>We have the constraint that we can't hold a position for more than K days                                                                   </li>
                       <li>A penalty of (1/K)% is applied to the profit for every day a position is held? <em>(where K is the condition and value described above)</em></li>
                       <li>Short selling is allowed?                                                                                                                   </li>
                       <li>We want to process independent sections of the time series concurrently so as to speed up overall processing time.                          </li>
                       <li>The prices could be extremely large or small?                                                                                               </li>
                       </ul>
                       <p></p>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="TokenGrid">Token Grid</a></h3>
                       <p align="left">
                        StrTk provides a means to easily parse and consume 2D grids of tokens
                        in an efficient and simple manner. A grid is simply defined as a
                        series of rows comprised of tokens, otherwise known as Delimiter
                        Separated Values (DSV). The ith token of a row is grouped with every
                        ith token of all other rows to produce a column. Tokens can be
                        processed as either rows or columns.<br> <br>

                        An example of a simple token grid, where each numeric value is deemed
                        to be a token:
                       </p>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
                       .tg .tg-e3zv{font-weight:bold}
                       .tg .tg-9hbo{font-weight:bold;vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr> <td class="tg-9hbo">1.1</td> <td class="tg-9hbo">2.2</td> <td class="tg-9hbo">3.3</td> <td class="tg-9hbo">4.4</td> <td class="tg-9hbo">5.5</td> </tr>
                         <tr> <td class="tg-9hbo">1.1</td> <td class="tg-9hbo">2.2</td> <td class="tg-9hbo">3.3</td> <td class="tg-9hbo">4.4</td> <td class="tg-9hbo">5.5</td> </tr>
                         <tr> <td class="tg-9hbo">1.1</td> <td class="tg-9hbo">2.2</td> <td class="tg-9hbo">3.3</td> <td class="tg-9hbo">4.4</td> <td class="tg-9hbo">5.5</td> </tr>
                         <tr> <td class="tg-9hbo">1.1</td> <td class="tg-9hbo">2.2</td> <td class="tg-9hbo">3.3</td> <td class="tg-9hbo">4.4</td> <td class="tg-9hbo">5.5</td> </tr>
                         <tr> <td class="tg-9hbo">1.1</td> <td class="tg-9hbo">2.2</td> <td class="tg-9hbo">3.3</td> <td class="tg-9hbo">4.4</td> <td class="tg-9hbo">5.5</td> </tr>
                       </tbody></table>

                       <p align="left">
                        A token grid can be either passed in via a file or a string buffer.
                        The delimiters to be used for parsing the columns and rows can also be
                        provided, if not provided standard common defaults will be used.<br> <br>

                        The following demonstrates how each cell in the grid can be access and
                        cast to a specific type.
                       </p>

                       <pre>
std::string data = "1,2,3,4,5,6\n"
                   "7,8,9,0,1,2\n"
                   "3,4,5,6,7,8\n"
                   "9,0,1,2,3,4\n"
                   "5,6,7,8,9,0\n";

strtk::token_grid grid(data, data.size(), ",");

for (std::size_t r = 0; r &lt; grid.row_count(); ++r)
{
   strtk::token_grid::row_type row = grid.row(r);

   for (std::size_t c = 0; c &lt; row.size(); ++c)
   {
      std::cout &lt;&lt; grid.get&lt;int&gt;(r,c) &lt;&lt; '\t';
   }

   std::cout &lt;&lt; std::endl;
}
                       </pre>

                       <p align="left">
                        The strtk::token_grid provides various helper functions for traversing
                        rows and columns in batch mode. The functions are namely: for_each_row
                        that is used for iterating either all or a sub-range of rows of the
                        token_grid, and for_each_column that is used for iterating either all
                        or a sub-range of columns of a row.
                       </p>

                       <pre>
int main()
{
              // Column 0   1   2   3   4   5   6
   std::string data = "1.1,2.1,3.1,4.1,5.1,6.1,7.1\n"  // row_0
                      "1.2,2.2,3.2,4.2,5.2,6.2,7.2\n"  // row_1
                      "1.3,2.3,3.3,4.3,5.3,6.3,7.3\n"  // row_2
                      "1.4,2.4,3.4,4.4,5.4,6.4,7.4\n"  // row_3
                      "1.5,2.5,3.5,4.5,5.5,6.5,7.5\n"  // row_4
                      "1.6,2.6,3.6,4.6,5.6,6.6,7.6\n"  // row_5
                      "1.7,2.7,3.7,4.7,5.7,6.7,7.7\n"  // row_6
                      "1.8,2.8,3.8,4.8,5.8,6.8,7.8\n"  // row_7
                      "1.9,2.9,3.9,4.9,5.9,6.9,7.9\n"; // row_8

   strtk::token_grid grid(data,data.size(),",");

   {
      // Process each row of the token grid
      grid.for_each_row(
         [](const strtk::token_grid::row_type&amp; row)
         {
            for (std::size_t i = 0; i &lt; row.size(); ++i)
            {
               std::cout &lt;&lt; row.get&lt;double&gt;(i) &lt;&lt; '\t';
            }
            std::cout &lt;&lt; '\n';
         });
   }

   {
      // Process rows in the range [2,6] of the token grid
      grid.for_each_row(grid.range(2,6),
         [](const strtk::token_grid::row_type&amp; row)
         {
            for (std::size_t i = 0; i &lt; row.size(); ++i)
            {
               std::cout &lt;&lt; row.get&lt;double&gt;(i) &lt;&lt; '\t';
            }
            std::cout &lt;&lt; '\n';
         });
   }

   {
      // Process each row and column of the token grid
      grid.for_each_row(
         [](const strtk::token_grid::row_type&amp; row)
         {
            row.for_each_column(
               [](const strtk::token_grid::row_type::range_type&amp; range)
               {
                  std::cout &lt;&lt; std::string(range.first,range.second) &lt;&lt; '\t';
               });
            std::cout &lt;&lt; '\n';
         });
   }

   {
      // Process rows in the range [2,6] and the columns in the range [1,5] of the token grid
      grid.for_each_row(grid.range(2,6),
         [](const strtk::token_grid::row_type&amp; row)
         {
            row.for_each_column(row.range(1,5),
               [](const strtk::token_grid::row_type::range_type&amp; range)
               {
                  std::cout &lt;&lt; std::string(range.first,range.second) &lt;&lt; '\t';
               });
            std::cout &lt;&lt; '\n';
         });
   }

   return 0;
}
                       </pre>

                       <p align="left">
                        The following example demonstrates how averages over rows and columns
                        of a token grid can be computed:
                       </p>

                       <pre>
std::string data = "1.1,1.1,1.1,1.1,1.1,1.1\n"
                   "2.2,2.2,2.2,2.2,2.2,2.2\n"
                   "3.3,3.3,3.3,3.3,3.3,3.3\n"
                   "4.4,4.4,4.4,4.4,4.4,4.4\n"
                   "5.5,5.5,5.5,5.5,5.5,5.5\n"
                   "6.6,6.6,6.6,6.6,6.6,6.6\n";

strtk::token_grid grid(data,data.size(),",");

std::vector&lt;double&gt; avg_c(grid.row(0).size(),0.0);
std::vector&lt;double&gt; avg_r(grid.row_count(),0.0);
std::vector&lt;double&gt; tmp(grid.row(0).size(),0.0);

std::fill(avg_c.begin(), avg_c.end(), 0.0);

for (std::size_t i = 0; i &lt; grid.row_count(); ++i)
{
   grid.row(i).parse&lt;double&gt;(tmp.begin());
   std::transform(avg_c.begin(), avg_c.end(), tmp.begin(), avg_c.begin(), std::plus&lt;double&gt;());
   avg_r[i] = std::accumulate(tmp.begin(), tmp.end(), 0.0) / tmp.size();
}

for (std::size_t i = 0; i &lt; avg_c.size(); avg_c[i++] /= grid.row_count());

std::cout &lt;&lt; "Column Averages:\t";
std::copy(avg_c.begin(),avg_c.end(),std::ostream_iterator&lt;double&gt;(std::cout,'\t'));
std::cout &lt;&lt; '\n';

std::cout &lt;&lt; "Row Averages:\t";
std::copy(avg_r.begin(),avg_r.end(),std::ostream_iterator&lt;double&gt;(std::cout,'\t'));
std::cout &lt;&lt; '\n';
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="ProcessingOfCommaSeparatedValuesData">Processing Of Comma Separated Values Data (CSV)</a></h3>
                       <p align="left">
                        The original intent of the token grid was to support fast and
                        efficient processing of simple data tuples, such as comma separated
                        values (CSV) formats et. al. The following example demonstrates a
                        simple summation of traded floor volume and average daily volume based
                        on NASDAQ OHLC (Open-High-Low-Close) data.
                       </p>

                       <pre>
                          // Date,Symbol,Open,Close,High,Low,Volume
std::string market_data = "20090701,GOOG,424.2000,418.9900,426.4000,418.1500,2310768\n"
                          "20090701,MSFT,24.0500,24.0400,24.3000,23.9600,54915127\n"
                          "20090702,GOOG,415.4100,408.4900,415.4100,406.8100,2517630\n"
                          "20090702,MSFT,23.7600,23.3700,24.0400,23.2100,65427699\n"
                          "20090703,GOOG,408.4900,408.4900,408.4900,408.4900,0\n"
                          "20090703,MSFT,23.3700,23.3700,23.3700,23.3700,0\n"
                          "20090706,GOOG,406.5000,409.6100,410.6400,401.6600,2262557\n"
                          "20090706,MSFT,23.2100,23.2000,23.2800,22.8700,49207638\n"
                          "20090707,GOOG,408.2400,396.6300,409.1900,395.9801,3260307\n"
                          "20090707,MSFT,23.0800,22.5300,23.1400,22.4600,52842412\n"
                          "20090708,GOOG,400.0000,402.4900,406.0000,398.0600,3441854\n"
                          "20090708,MSFT,22.3100,22.5600,22.6900,2200000,73023306\n"
                          "20090709,GOOG,406.1200,410.3900,414.4500,405.8000,3275816\n"
                          "20090709,MSFT,22.6500,22.4400,22.8100,22.3700,46981174\n"
                          "20090710,GOOG,409.5700,414.4000,417.3700,408.7000,2929559\n"
                          "20090710,MSFT,22.1900,22.3900,22.5400,22.1500,43238698\n";

strtk::token_grid grid(market_data, market_data.size(), ",");

struct stock_info
{
   stock_info(const std::string&amp; s = " ")
   : symbol(s),
     total_volume(0),
     day_count(0),
     average_daily_volume(0.0)
   {}

   std::string symbol;
   unsigned long long total_volume;
   std::size_t day_count;
   double average_daily_volume;
};

stock_info goog("GOOG");
stock_info msft("MSFT");

static const std::size_t volume_column = 6;
static const std::size_t symbol_column = 1;

goog.day_count = grid.accumulate_column
                    (volume_column,
                    [](const strtk::token_grid::row_type&amp; row) -&gt; bool
                    {
                       static const std::string google_symbol("GOOG");
                       return google_symbol == row.get&lt;std::string&gt;(symbol_column);
                    },
                    goog.total_volume);

msft.day_count = grid.accumulate_column
                    (volume_column,
                    [](const strtk::token_grid::row_type&amp; row) -&gt; bool
                    {
                       static const std::string microsoft_symbol("MSFT");
                       return microsoft_symbol == row.get&lt;std::string&gt;(symbol_column);
                    },
                    msft.total_volume);

goog.average_daily_volume = (1.0 * goog.total_volume) / goog.day_count;
msft.average_daily_volume = (1.0 * msft.total_volume) / msft.day_count;

std::cout &lt;&lt; "[GOOG] Total Volume: " &lt;&lt; goog.total_volume &lt;&lt; std::endl;
std::cout &lt;&lt; "[MSFT] Total Volume: " &lt;&lt; msft.total_volume &lt;&lt; std::endl;

std::cout &lt;&lt; "[GOOG] ADV: " &lt;&lt; goog.average_daily_volume &lt;&lt; std::endl;
std::cout &lt;&lt; "[MSFT] ADV: " &lt;&lt; msft.average_daily_volume &lt;&lt; std::endl;
                       </pre>

                       <p align="left">
                        The strtk::token_grid is thread-safe iff read operations are in play.
                        As such the above calls to accumulate_column et al. can all be safely
                        and easily executed concurrently using threads. This allows for a far
                        more efficient data processing methodology.
                       </p>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="TIMTOWTDI">TIMTOWTDI</a></h3>
                       <p align="left">
                        Playing devil's advocate, another way of performing the above
                        processing task, assuming only the specific values for computing the
                        ADV are required and no further processing of the CSV data is needed,
                        then the problem can be solved efficiently by utilizing a single pass
                        of the data as follows:
                       </p>

                       <pre>
std::string file_name = "market_data.csv";

std::unordered_map<std::string,stock_info> stock_map;

stock_map.insert(std::make_pair<std::string,stock_info>("GOOG",stock_info("GOOG")));
stock_map.insert(std::make_pair<std::string,stock_info>("MSFT",stock_info("MSFT")));

strtk::for_each_line(file_name,
                     [&amp;](const std::string&amp; line)
                     {
                        strtk::ignore_token ignore;
                        stock_info temp;

                        const bool result = strtk::parse(line,
                                                         ",",
                                                         ignore,
                                                         temp.symbol,
                                                         ignore,
                                                         ignore,
                                                         ignore,
                                                         ignore,
                                                         temp.total_volume);

                        if (!result) return;

                        auto itr = stock_map.find(temp.symbol);

                        if (stock_map.end() == itr) return;

                        (*itr).second.total_volume += temp.total_volume;
                        (*itr).second.day_count++;
                     });

auto itr = stock_map.begin();
auto end = stock_map.end();

while (end != itr)
{
   stock_info&amp; stock = (*itr++).second;

   stock.average_daily_volume = (1.0 * stock.total_volume) / stock.day_count;
}
                       </std::string,stock_info></std::string,stock_info></std::string,stock_info></pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="TIMTOWTDI2">TIMTOWTDI 2.0 <em>(with a vengeance)</em></a></h3>
                       <p align="left">
                        Playing the devil's other advocate, the above two examples, have both
                        required that the filter condition be explicitly defined at compile
                        time. However even though the condition maybe be set in stone at
                        compile time, some of the underlyings <em>(such as symbol)</em> can be
                        engineered to be modified at run-time. That still doesn't give us the
                        freedom to perform arbitrarily complex filter expressions determined
                        at run-time.<br> <br>

                        That said, an extremely efficient and very simple solution is at hand.
                        The solution is called the <b>C++ DSV Filter Library</b>, it is based
                        on StrTK and ExprTk libraries. It uses the <b>strtk::token_grid</b> as
                        a CSV/DSV store and index, and ExprTk as the underlying expression
                        evaluation engine. The example below takes the OHLC market data table
                        defined above and performs a row-wise query. The expression's
                        definition is:<br> <br>

                        <em>
                        'select all rows where the open price is greater than the close price
                        and the symbol matches the wild-card pattern of "*FT*" and the date is
                        equal to or after 20090101'
                        </em>
                       </p>

                       <pre>
int main()
{
   std::string file_name = "market_data.csv";

   dsv_filter filter;

   filter.set_input_delimiter(",");

   if (!filter.load(file_name))
      return 1;

   std::string expression = "(open &gt; close) and (symbol like '*FT*') and (date &gt;= '20090101')";

   filter.add_filter(filter_expression);

   for (std::size_t row = 1; row &lt; filter.row_count(); ++row)
   {
      if (dsv_filter::e_match == filter[row])
      {
          // do something...
      }
   }

   return 0;
}
                       </pre>

                       <p align="left">
                        <b>Other example queries:</b>
                        </p><ul style="text-align: left">
                        <li>volume &gt;= 1000000 and symbol == 'GOOG'                                          </li>
                        <li>abs(open - close) &gt; abs(high - low)                                             </li>
                        <li>avg(open,close,high,low) * volume &gt; 10^7 and inrange('20090702',date,'20090730')</li>
                        <li>(open &gt; close) and (symbol like '*FT*') and (date &gt;= '20090101')                </li>
                        </ul>
                       <p></p>

                       <p align="left">
                        It should be noted that in the example above, the rows begin at index
                        1. That is done because the dsv_filter expects the first row or row at
                        index 0 to be a column definition header. The format of the column
                        definitions is to simply add a suffix of "_s" if the values in the
                        column are to be treated as strings or "_n" if they are to be treated
                        as numbers. When defining expressions the suffixes should not be
                        included when including the column names. The above mentioned OHLC csv
                        file's header would be as follows:
                       </p>

                       <pre>
Date_s,Symbol_s,Open_n,Close_n,High_n,Low_n,Volume_n
                       </pre>

                       <p align="left">
                        <b>C++ DSV Filter and Dependencies</b>
                        </p><ul style="text-align: left">
                        <li><a href="http://www.partow.net/programming/dsvfilter/index.html"><b>DSV Filter</b> - http://www.partow.net/programming/dsvfilter/index.html</a></li>
                        <li><a href="http://www.partow.net/programming/exprtk/index.html">   <b>ExprTK</b>     - http://www.partow.net/programming/exprtk/index.html</a></li>
                        </ul>
                       <p></p>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="Sequential Partitions">Sequential Partitions</a></h3>
                       <p align="left">
                        A typical operation carried out upon time-series data is to group
                        tuples into buckets (or bins) based upon the time index value. For
                        example grouping data into 2-minute buckets and then performing some
                        kind of operation upon the grouped tuples such as a summation or an
                        average etc. This process is sometimes also called: "discretization"<br> <br>

                        The strtk::token_grid class provides a method known as
                        sequential_partition. The sequential_partition method requires a
                        Transition Predicate, a Function and optionally a row-range. The
                        Transition Predicate consumes a row and returns true only if the row
                        is in the next partition. All other subsequent consecutive rows until
                        the transition predicate returns a true are said to be in the current
                        partition. Prior to transitioning to a new partition, the function
                        predicate is invoked and provided with the range of rows in the
                        current partition.<br> <br>

                        The following example takes a simple time-series (time and value),
                        partitions the tuples into groups of Time-Buckets of period length 3
                        and then proceeds to compute the total sum of each group. The below
                        summarizer class provides provides a Transition Predicate and
                        Function.
                       </p>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_seqpart.png" alt="C++ String Toolkit Library Sequential Partition - Copyright Arash Partow" border="0">
                       </p>

                       <pre>
class summarizer
{
public:

   enum column_index
   {
      tick_time_column  = 0,
      tick_value_column = 1
   };

   summarizer(std::deque&lt;double&gt;&amp; sum_value)
   : next_tick_time_(0),
     sum_value_(sum_value)
   {}

   // Transition Predicate
   bool operator()(const strtk::token_grid::row_type&amp; row)
   {
      if (row.get<std::size_t>(tick_time_column) &gt;= next_tick_time_)
      {
         next_tick_time_ = row.get<std::size_t>(tick_time_column) + 3;

         return true;
      }
      else
         return false;
   }

   // Function
   bool operator()(const strtk::token_grid&amp; grid,
                   const strtk::token_grid::row_range_type&amp; range)
   {
      double bucket_sum = 0.0;

      if (!grid.accumulate_column(tick_value_column,range,bucket_sum))
      {
         std::cout &lt;&lt; "failed to accumulate!" &lt;&lt; std::endl;

         return false;
      }
      else
         sum_value_.push_back(bucket_sum);

      return true;
   }

private:

   summarizer&amp; operator=(const summarizer&amp;);

   std::size_t next_tick_time_;
   std::deque&lt;double&gt;&amp; sum_value_;
};

int main()
{
                    // Time index, Value
   std::string data = "10000,123.456\n"
                      "10001,612.345\n"
                      "10002,561.234\n"
                      "10003,456.123\n"
                      "10004,345.612\n"
                      "10005,234.561\n"
                      "10006,123.456\n";

   strtk::token_grid grid(data, data.size(), ",");

   std::deque&lt;double&gt; sum_value;

   summarizer s(sum_value);

   grid.sequential_partition(s,s);

   for (std::size_t i = 0; i &lt; sum_value.size(); ++i)
   {
      std::cout &lt;&lt; "bucket[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; sum_value[i] &lt;&lt; std::endl;
   }

   return 0;
}
                       </std::size_t></std::size_t></pre>

                       <p align="left">
                        The expected output is as follows:
                       </p>

                       <pre>
bucket[0] = 1297.035
bucket[1] = 1036.296
bucket[2] = 123.456
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="ParsingCSVFilesWithEmbeddedDoubleQuotes">Parsing CSV Files With Embedded Double-Quotes</a></h3>
                       <p align="left">
                        One of the simple extensions to the CSV format is the concept of
                        double quoted tokens. Such tokens may contain column or row
                        delimiters. When such a scenario is encountered, all subsequent
                        delimiters are ignored, and kept as part of the token, until the
                        corresponding closing double quote is encountered. The StrTk
                        token_grid supports the parsing of such tokens. This parsing mode can
                        be easily activated via the token_grid option set. Below is an example
                        of a token_grid loading a CSV data set representing various airports
                        from around the world and their specific codes and locations, in which
                        some of the cells are double-quoted:
                       </p>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-hgcj{font-weight:bold;text-align:center}
                       .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr> <th class="tg-hgcj">ICAO</th> <th class="tg-hgcj">IATA</th> <th class="tg-hgcj">Airport</th> <th class="tg-hgcj">City</th> <th class="tg-hgcj">Country</th> </tr>
                         <tr> <td class="tg-hgcj">AYGA</td> <td class="tg-031e">GKA</td> <td class="tg-031e">"Goroka Gatue"                 </td> <td class="tg-031e">Goroka               </td> <td class="tg-031e">Papua New Guinea</td> </tr>
                         <tr> <td class="tg-hgcj">BGCO</td> <td class="tg-031e">GCO</td> <td class="tg-031e">"Nerlerit Inaat Constable Pynt"</td> <td class="tg-031e">"Nerlerit Inaat"     </td> <td class="tg-031e">Greenland       </td> </tr>
                         <tr> <td class="tg-hgcj">BZGD</td> <td class="tg-031e">ZGD</td> <td class="tg-031e">Godley                         </td> <td class="tg-031e">Auckland             </td> <td class="tg-031e">New Zealand     </td> </tr>
                         <tr> <td class="tg-hgcj">CYQM</td> <td class="tg-031e">YQM</td> <td class="tg-031e">"Greater Moncton International"</td> <td class="tg-031e">Moncton              </td> <td class="tg-031e">Canada          </td> </tr>
                         <tr> <td class="tg-amwm">EDRK</td> <td class="tg-yw4l">ZNV</td> <td class="tg-yw4l">"Koblenz Winningen"            </td> <td class="tg-yw4l">Koblenz              </td> <td class="tg-yw4l">Germany         </td> </tr>
                         <tr> <td class="tg-amwm">FAHU</td> <td class="tg-yw4l">AHU</td> <td class="tg-yw4l">"HMS Bastard Memorial"         </td> <td class="tg-yw4l">Kwazulu-Natal        </td> <td class="tg-yw4l">South Africa    </td> </tr>
                         <tr> <td class="tg-amwm">FQMP</td> <td class="tg-yw4l">MZB</td> <td class="tg-yw4l">"Mocimboa Da Praia"            </td> <td class="tg-yw4l">"Mocimboa Da Praia"  </td> <td class="tg-yw4l">Mozambique      </td> </tr>
                         <tr> <td class="tg-amwm">KINS</td> <td class="tg-yw4l">INS</td> <td class="tg-yw4l">"Indian Springs AF AUX"        </td> <td class="tg-yw4l">Indian Springs       </td> <td class="tg-yw4l">USA             </td> </tr>
                         <tr> <td class="tg-amwm">UHNN</td> <td class="tg-yw4l">HNN</td> <td class="tg-yw4l">Nikolaevsk                     </td> <td class="tg-yw4l">"Nikolaevsk Na Amure"</td> <td class="tg-yw4l">Russia          </td> </tr>
                         <tr> <td class="tg-amwm">WBKK</td> <td class="tg-yw4l">BKI</td> <td class="tg-yw4l">"Kota Kinabalu International"  </td> <td class="tg-yw4l">Kota Kinabalu        </td> <td class="tg-yw4l">Malaysia        </td> </tr>
                         <tr> <td class="tg-amwm">ZSJD</td> <td class="tg-yw4l">JDZ</td> <td class="tg-yw4l">"Jingdezhen Airport"           </td> <td class="tg-yw4l">Jingdezhen           </td> <td class="tg-yw4l">China           </td> </tr>
                       </tbody></table>

                       <p align="left">
                        The following is an StrTk code example using token_grid to parse the above CSV data set:
                       </p>

                       <pre>
int main()
{
   std::string airport_data_file_name = "airport_data.csv";

   strtk::token_grid::options options;
   options.column_delimiters = "| ,";
   options.support_dquotes = true;

   strtk::token_grid airport_grid(airport_data_file_name,options);

   // for each row r, for each column c, print cell[r,c]
   for (std::size_t r = 0; r &lt; airport_grid.row_count(); ++r)
   {
      strtk::token_grid::row_type row = airport_grid.row(r);

      for (std::size_t c = 0; c &lt; row.size(); ++c)
      {
         std::cout &lt;&lt; "[" &lt;&lt; row.get&lt;std::string&gt;(c) &lt;&lt; "] ";
      }

      std::cout &lt;&lt; std::endl;
   }

   return 0;
}
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="ExtendingDelimiterPredicates">Extending Delimiter Predicates</a></h3>
                       <p align="left">
                        As previously mentioned the concept of a delimiter based predicate can
                        lead to some very interesting solutions. A predicate as has been
                        defined so far, with the exception of the offset predicate, has been a
                        stateless entity. Adding the ability to maintain a state based on what
                        the predicate has encountered so far can allow it to behave
                        differently from the simple single and multiple delimiter predicates.<br> <br>

                        For this example, lets assume a typical command line parsing problem
                        which consists of double quotation mark groupings and escapable
                        special characters, which can be considered being dual use as either
                        delimiters or data. An example input and output is as follows:
                       </p>

                       <h4 align="left">Inputs</h4>
                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr><td class="tg-031e">Data      </td><td class="tg-031e">abc;"123, mno xyz",i\,jk</td></tr>
                         <tr><td class="tg-yw4l">Delimiters</td><td class="tg-yw4l">&lt;space&gt;;,.        </td></tr>
                       </tbody></table>

                       <h4 align="left">Output Tokens</h4>
                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr><td class="tg-031e">Token<sub>0</sub></td><td class="tg-031e">abc         </td></tr>
                         <tr><td class="tg-yw4l">Token<sub>1</sub></td><td class="tg-yw4l">123, mno xyz</td></tr>
                         <tr><td class="tg-yw4l">Token<sub>2</sub></td><td class="tg-yw4l">i\,jk       </td></tr>
                       </tbody></table>

                       <p align="left">
                        In order to tokenize the above described string, one can create a
                        composite predicate using a multiple char delimiter predicate and some
                        simple state rules. The following is an example of such an extended
                        predicate:
                       </p>

                       <pre>
class extended_predicate
{
public:

   extended_predicate(const std::string&amp; delimiters)
   : escape_(false),
     in_bracket_range_(false),
     mdp_(delimiters)
   {}

   bool operator()(const unsigned char c) const
   {
      if (escape_)
      {
         escape_ = false;
         return false;
      }
      else if ('\\' == c)
      {
         escape_ = true;
         return false;
      }
      else if ('"' == c)
      {
         in_bracket_range_ = !in_bracket_range_;
         return true;
      }
      else if (in_bracket_range_)
         return false;
      else
         return mdp_(c);
   }

   void reset()
   {
      escape_ = false;
      in_bracket_range_ = false;
   }

private:

   mutable bool escape_;
   mutable bool in_bracket_range_;
   mutable strtk::multiple_char_delimiter_predicate mdp_;
};
                       </pre>

                       <p align="left">
                        Usage of the newly defined extended predicate is as follows:
                       </p>

                       <pre>
int main()
{
   std::string str = "abc;\"123, mno xyz\",i\\,jk";

   strtk::std_string::token_list_type token_list;

   strtk::split(extended_predicate(".,; "),
                str,
                std::back_inserter(token_list),
                strtk::split_options::compress_delimiters);

   return 0;
}
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="HighPerformanceKeyValueParsing">High Performance Key-Value Parsing</a></h3>
                       <p align="left">
                        Taking our previous person struct as an example. It is clear that the
                        tuple format has to be very specific with regards to the ordering of
                        data. For most situations this is acceptable as the serializers and
                        deserializers attempt to function in the simplest manner possible,
                        however sometimes pieces of information may come in different
                        orderings, or may be deemed optional and hence not be present in a
                        particular tuple of data.<br> <br>

                        An approach is required that provides the means of mapping specific
                        pieces of data to the corresponding variables <em>(or members)</em>
                        that will store or make sense of them, in a very efficient and simple
                        manner. For clarity purposes, the term "mapping" here means to populate
                        the desired member with the given data. The association between the
                        two being made with the key that is paired in-line with the data.
                        Key-Value pairs or some times known as Attribute-Value pairs are one
                        of the means by which such an association can be accomplished. The
                        following is a diagram that demonstrates the mapping of various fields
                        of a data struct to their corresponding data elements in a tuple
                        comprised of key-value pairs.
                       </p>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_key_value_pairs.png" alt="C++ String Toolkit Library Key Value Pair Parsing - Copyright Arash Partow" border="0">
                       </p>

                       <p align="left">
                        In the diagram above, the key-value pairs are separated (delimited) by
                        the pipe symbol "|". With regards to the key-value pairs themselves,
                        the key is traditionally the first element in the pair and the value
                        is the second element, they are separated in this case by a single
                        equal sign "=".<br> <br>

                        Back to our original problem relating to the person struct. If we were
                        to add keys to each of the pieces of data, we could then not only
                        parse a tuple of data representing the various fields of the person
                        struct, but those fields could be any order within the tuple.
                        Furthermore any of the fields could be deemed optional, hence not
                        necessarily be present in the tuple. It should be noted that what
                        would denote a correct or successful parse of tuple may not only
                        depend upon successful parsing of ranges into the various types, but
                        it may also depend upon the mandatory presence of certain fields.<br> <br>

                        Our objective will be to successfully and in the most efficient way
                        possible parse the following list of tuples that represent instances
                        of our person struct.
                       </p>

                       <pre>
Tuple0 = "ID=0xFA37ED12|NAME=Rumpelstiltskin|AGE=397|HEIGHT=1.31|WEIGHT=58.7"
Tuple1 = "NAME=Rumpelstiltskin|AGE=397|HEIGHT=1.31|WEIGHT=58.7|ID=0xFA37ED12"
Tuple2 = "AGE=397|HEIGHT=1.31|WEIGHT=58.7|ID=0xFA37ED12|NAME=Rumpelstiltskin"
Tuple3 = "HEIGHT=1.31|WEIGHT=58.7|ID=0xFA37ED12|NAME=Rumpelstiltskin|AGE=397"
Tuple4 = "WEIGHT=58.7|ID=0xFA37ED12|NAME=Rumpelstiltskin|AGE=397|HEIGHT=1.31"
Tuple5 = "ID=0xFA37ED12|WEIGHT=58.7|AGE=397|NAME=Rumpelstiltskin|HEIGHT=1.31"
Tuple6 = "WEIGHT=58.7|AGE=397|NAME=Rumpelstiltskin|HEIGHT=1.31|ID=0xFA37ED12"
Tuple7 = "AGE=397|NAME=Rumpelstiltskin|HEIGHT=1.31|ID=0xFA37ED12|WEIGHT=58.7"
Tuple8 = "NAME=Rumpelstiltskin|HEIGHT=1.31|ID=0xFA37ED12|WEIGHT=58.7|AGE=397"
Tuple9 = "HEIGHT=1.31|ID=0xFA37ED12|WEIGHT=58.7|AGE=397|NAME=Rumpelstiltskin"
                       </pre>

                       <p align="left">
                        StrTk provides a means to achieve the above key-value pair parsing
                        task, namely via the strtk::keyvalue::parser and associated key-
                        mappers. The following is a table that depicts the various kind of key
                        to value mappers that are available in the StrTk library:
                       </p>

                       <h3 align="left"><a name="KeyToValueMappers">Key To Value Mappers</a></h3>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-hgcj{font-weight:bold;text-align:center}
                       .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr><th class="tg-hgcj">Mapper</th><th class="tg-hgcj">Type</th><th class="tg-amwm">Key Lookup Complexity</th><th class="tg-amwm">Maximum Size</th></tr>
                         <tr><td class="tg-031e">strtk::keyvalue::stringkey_map</td><td class="tg-031e">std::string   </td><td class="tg-amwm">O(log(n))</td><td class="tg-yw4l">Limited to available memory          </td></tr>
                         <tr><td class="tg-031e">strtk::keyvalue::uintkey_map  </td><td class="tg-031e">cardinal value</td><td class="tg-amwm">O(1)     </td><td class="tg-yw4l">Limited to expected maximum key value</td></tr>
                       </tbody></table>

                       <p align="left">
                        In the code below we initially begin by defining the delimiters we
                        expect to see between pairs of key-values and in between the key and
                        value pairs themselves. In the example below the pair_block_delimiter
                        field denotes the delimiter we expect between pairs (or blocks) of
                        key-values and the field pair_delimiter denotes the delimiter we
                        expect between a particular key and value.<br><br>

                        Next we define p as an instance of the person struct and register each
                        of the members of the instance p with a corresponding key with the
                        keyvalue::parser. After which we then process each tuple of data,
                        parsing the tuple, populating the instance p, then printing out the
                        various fields to stdout.
                       </p>

                       <pre>
struct person
{
   unsigned int id;  // key = ID
   std::string name; // key = NAME
   unsigned int age; // key = AGE
   double height     // key = HEIGHT
   float weight;     // key = WEIGHT
};

int main()
{
   const std::string person_data[] =
            {
               "ID=0xFA37ED12|NAME=Rumpelstiltskin|AGE=397|HEIGHT=1.31|WEIGHT=58.7",
               "NAME=Rumpelstiltskin|AGE=397|HEIGHT=1.31|WEIGHT=58.7|ID=0xFA37ED12",
               "AGE=397|HEIGHT=1.31|WEIGHT=58.7|ID=0xFA37ED12|NAME=Rumpelstiltskin",
               "HEIGHT=1.31|WEIGHT=58.7|ID=0xFA37ED12|NAME=Rumpelstiltskin|AGE=397",
               "WEIGHT=58.7|ID=0xFA37ED12|NAME=Rumpelstiltskin|AGE=397|HEIGHT=1.31",
               "ID=0xFA37ED12|WEIGHT=58.7|AGE=397|NAME=Rumpelstiltskin|HEIGHT=1.31",
               "WEIGHT=58.7|AGE=397|NAME=Rumpelstiltskin|HEIGHT=1.31|ID=0xFA37ED12",
               "AGE=397|NAME=Rumpelstiltskin|HEIGHT=1.31|ID=0xFA37ED12|WEIGHT=58.7",
               "NAME=Rumpelstiltskin|HEIGHT=1.31|ID=0xFA37ED12|WEIGHT=58.7|AGE=397",
               "HEIGHT=1.31|ID=0xFA37ED12|WEIGHT=58.7|AGE=397|NAME=Rumpelstiltskin",
            };

   const std::size_t person_data_size = sizeof(person_data) / sizeof(std::string);

   // Basic type definition
   typedef unsigned char char_type;
   typedef strtk::keyvalue::parser<strtk::keyvalue::stringkey_map> kvp_type;
   typedef strtk::keyvalue::options&lt;char_type&gt; opts_type;

   // Setup the various delimiters
   opts_type options;
   options.pair_block_delimiter = '|';
   options.pair_delimiter       = '=';

   kvp_type kvp(options);

   person p;

   strtk::hex_to_number_sink<unsigned int=""> h2ns(p.id);

   // Define the mapping between the key and the
   // members of the person struct
   kvp.register_keyvalue("ID"    ,     h2ns);
   kvp.register_keyvalue("NAME"  , p.  name);
   kvp.register_keyvalue("AGE"   , p.   age);
   kvp.register_keyvalue("HEIGHT", p.height);
   kvp.register_keyvalue("WEIGHT", p.weight);

   // Go through each tuple
   for (std::size_t i = 0; i &lt; person_data_size; ++i)
   {
      // If parsing of the ith tuple is successful
      // print the person struct out.
      if (kvp(person_data[i]))
      {
         std::cout &lt;&lt; i                      &lt;&lt; '\t'
                   &lt;&lt; "ID: "     &lt;&lt; p.id     &lt;&lt; '\t'
                   &lt;&lt; "Name: "   &lt;&lt; p.name   &lt;&lt; '\t'
                   &lt;&lt; "AGE: "    &lt;&lt; p.age    &lt;&lt; '\t'
                   &lt;&lt; "HEIGHT: " &lt;&lt; p.height &lt;&lt; '\t'
                   &lt;&lt; "WEIGHT: " &lt;&lt; p.weight &lt;&lt; '\n';
     }
   }

   return 0;
}
                       </unsigned></strtk::keyvalue::stringkey_map></pre>

                       <p align="left">
                        It should be noted that the underlying associative container for the
                        strtk::keyvalue::stringkey_map can be explicitly specified at compile
                        time. By default it is std::map, however it can be easily changed to
                        std::unordered_map giving it a key lookup complexity of O(1) or in
                        fact any other container that is compatible with STL associative map
                        semantics. The following are three examples of keyvalue_parsers
                        specialized using std::unordered_map, the first being based on the
                        std::string type, the second being based on the int type and the third
                        being based on the double type:
                       </p>

                       <pre>
int main()
{
   // std::string type key to value mapper based on std::unordered_map
   {
      // Basic type definition
      typedef unsigned char char_type;
      typedef std::unordered_map<std::string,strtk::util::value> key_to_val_map_t;
      typedef strtk::keyvalue::key_map<std::string,key_to_val_map_t> stringhashkey_mapper;
      typedef strtk::keyvalue::parser<stringhashkey_mapper> kvp_type;
      typedef strtk::keyvalue::options&lt;char_type&gt; opts_type;

      //Setup the various delimiters
      opts_type options;
      options.pair_block_delimiter = '|';
      options.pair_delimiter       = '=';

      kvp_type kvp(options);
   }

   // int type key to value mapper based on std::unordered_map
   {
      // Basic type definition
      typedef unsigned char char_type;
      typedef std::unordered_map<int,strtk::util::value> key_to_val_map_t;
      typedef strtk::keyvalue::key_map<int,key_to_val_map_t> inthash_key_mapper;
      typedef strtk::keyvalue::parser<inthash_key_mapper> kvp_type;
      typedef strtk::keyvalue::options&lt;char_type&gt; opts_type;

      // Setup the various delimiters
      opts_type options;
      options.pair_block_delimiter = '|';
      options.pair_delimiter       = '=';

      kvp_type kvp(options);
   }

   // double type key to value mapper based on std::unordered_map
   {
      // Basic type definition
      typedef unsigned char char_type;
      typedef std::unordered_map<double,strtk::util::value> key_to_val_map_t;
      typedef strtk::keyvalue::key_map<double,key_to_val_map_t> doublehash_key_mapper;
      typedef strtk::keyvalue::parser<doublehash_key_mapper> kvp_type;
      typedef strtk::keyvalue::options&lt;char_type&gt; opts_type;

      // Setup the various delimiters
      opts_type options;
      options.pair_block_delimiter = '|';
      options.pair_delimiter       = '=';

      kvp_type kvp(options);
   }

   return 0;
}
                       </doublehash_key_mapper></double,key_to_val_map_t></double,strtk::util::value></inthash_key_mapper></int,key_to_val_map_t></int,strtk::util::value></stringhashkey_mapper></std::string,key_to_val_map_t></std::string,strtk::util::value></pre>

                       <h3 align="left"><a name="KeyValuePairsAndMultipleDistinctDataStructures">Key-Value Pairs And Multiple Distinct Data Structures</a></h3>
                       <p align="left">
                        To further the previous example, one might have a situation where a
                        tuple contains values for different members of different types. The
                        following example demonstrates parsing of key-value pairs that map to
                        members of multiple types. The tuple in the example consists of values
                        some of which are intended for the instance of data1 and others which
                        are intended for the instance of data2.
                       </p>

                       <pre>
struct data1
{
   int x0;
   std::string x1;
   double x2;
   float x3;
}

struct data2
{
   int y0;
   std::string y1;
   double y2;
   float y3;
}

int main()
{
   typedef unsigned char char_type;
   typedef strtk::keyvalue::parser<strtk::keyvalue::stringkey_map> kvp_type;
   typedef strtk::keyvalue::options&lt;char_type&gt; opts_type;

   opts_type options;
   options.pair_block_delimiter = '|';
   options.pair_delimiter       = '=';

   kvp_type kvp(options);

   data1 d1;
   data2 d2;

   std::string data = "D1X0=123456789|D1X1=AbCdEfG123456|D1X2=123.456|D1X3=0101.0202f|"
                      "D2Y0=987654321|D2Y1=tUvWxYz789012|D2Y2=789.012|D2Y3=0707.0909f";

   // Register values for data1 type
   kvp.register_keyvalue("D1X0", d1.x0);
   kvp.register_keyvalue("D1X1", d1.x1);
   kvp.register_keyvalue("D1X2", d1.x2);
   kvp.register_keyvalue("D1X3", d1.x3);

   // Register values for data2 type
   kvp.register_keyvalue("D2Y0", d2.y0);
   kvp.register_keyvalue("D2Y1", d2.y1);
   kvp.register_keyvalue("D2Y2", d2.y2);
   kvp.register_keyvalue("D2Y3", d2.y3);

   // Parse the tuple
   kvp(data);

   std::cout &lt;&lt; "D1X0: " &lt;&lt; d1.x0 &lt;&lt; '\t'
             &lt;&lt; "D1X1: " &lt;&lt; d1.x1 &lt;&lt; '\t'
             &lt;&lt; "D1X2: " &lt;&lt; d1.x2 &lt;&lt; '\t'
             &lt;&lt; "D1X3: " &lt;&lt; d1.x3 &lt;&lt; '\n';

   std::cout &lt;&lt; "D2Y0: " &lt;&lt; d2.y0 &lt;&lt; '\t'
             &lt;&lt; "D2Y1: " &lt;&lt; d2.y1 &lt;&lt; '\t'
             &lt;&lt; "D2Y2: " &lt;&lt; d2.y2 &lt;&lt; '\t'
             &lt;&lt; "D2Y3: " &lt;&lt; d2.y3 &lt;&lt; '\n';

   return 0;
}
                       </strtk::keyvalue::stringkey_map></pre>

                       <h3 align="left"><a name="KeyValuePairsAndLists">Key-Value Pairs And Lists</a></h3>
                       <p align="left">
                        The values in the key-value pairs need not always be singular. In some
                        scenarios, a value could be a list of values. The StrTk key-value
                        parser supports parsing of such key-value pairs through the previously
                        demonstrated sequence sink mechanisms.<br><br>

                        In the following example we have a complex_data struct that consists
                        of some PODs but also a number of sequences (vector, deque, list). The
                        tuple to be parsed consists of simple key-value pairs for the PODs and
                        more complex looking pairs where the values for the specific sequence
                        of values are separated by commas ",".
                       </p>

                       <pre>
struct complex_data
{
   unsigned int           v0;
   std::vector&lt;int&gt;       v1;
   double                 v2;
   std::deque&lt;double&gt;     v3;
   std::string            v4;
   std::list&lt;std::string&gt; v5;
};

int main()
{
   typedef unsigned char char_type;
   typedef strtk::keyvalue::parser&lt;strtk::keyvalue::stringkey_map&gt; kvp_type;
   typedef strtk::keyvalue::options&lt;char_type&gt; opts_type;

   opts_type options;

   options.pair_block_delimiter = '|';
   options.pair_delimiter       = '=';

   kvp_type kvp(options);

   complex_data cd;

   std::string data = "V0=123456789|V1=-3,-2,-1,0,+1,2+3|V2=111.222|V3=1.1,2.2,3.3,4.4,5.5|"
                      "V4=Some Text|V5=Text1,Text2,Text3,Text4";

   strtk::vector_sink&lt;int&gt;::type vec_sink(",");
   strtk::deque_sink&lt;double&gt;::type deq_sink(",");
   strtk::list_sink&lt;std::string&gt;::type lst_sink(",");

   // Register values for data1 type
   kvp.register_keyvalue("V0", cd.v0);
   kvp.register_keyvalue("V1", vec_sink(cd.v1));
   kvp.register_keyvalue("V2", cd.v2);
   kvp.register_keyvalue("V3", deq_sink(cd.v3));
   kvp.register_keyvalue("V4", cd.v4);
   kvp.register_keyvalue("V5", lst_sink(cd.v5));

   kvp(data);

   std::cout &lt;&lt; "V0: " &lt;&lt; cd.v0 &lt;&lt; '\n'
             &lt;&lt; "V1: " &lt;&lt; strtk::join(" ",cd.v1) &lt;&lt; '\n'
             &lt;&lt; "V2: " &lt;&lt; cd.v2 &lt;&lt; '\n'
             &lt;&lt; "V3: " &lt;&lt; strtk::join(" ",cd.v3) &lt;&lt; '\n'
             &lt;&lt; "V4: " &lt;&lt; cd.v4 &lt;&lt; '\n'
             &lt;&lt; "V5: " &lt;&lt; strtk::join(" ",cd.v5) &lt;&lt; '\n';

   return 0;
}
                       </pre>

                       <h3 align="left"><a name="KeyValuePairsWithCardinalKeys">Key-Value Pairs With Cardinal Keys</a></h3>
                       <p align="left">
                        So far all the examples have assumed keys of arbitrary values. In some
                        situations such as the <a href="http://en.wikipedia.org/wiki/Financial_Information_eXchange"><b>FIX protocol</b></a>,
                        the keys are always guaranteed to be positive integer values. If this
                        is the case then a different kind of key-mapper can be used that is much
                        more efficient than the general purpose string key-mapper, providing a
                        key lookup complexity of <b>O(1)</b>. As such StrTk provides the <b>strtk::keyvalue::uintkey_map</b>
                        type for this purpose. The only difference in terms of setting up the
                        uintkey_map from the stringkey_map is that it requires a key_count to
                        be set. This value represents the largest possible key value that can
                        exist. The following is an example of how the <b>strtk::keyvalue::uintkey_map</b>
                        key-mapper can be used.
                       </p>

                       <pre>
struct data_store
{
   char            c; // key = 121
   unsigned char  uc; // key = 122
   short           s; // key = 123
   unsigned short us; // key = 124
   int             i; // key = 125
   std::string   str; // key = 126
};

int main()
{
   const std::string data = "121=A|122=z|123=-123|124=456|125=-12345678|126=Some simple text";

   typedef strtk::keyvalue::parser&lt;strtk::keyvalue::uintkey_map&gt; kvp_type;

   strtk::keyvalue::uintkey_map::options options;

   options.key_count            = 127; // [0,126] --&gt; 127 keys
   options.pair_block_delimiter = '|';
   options.pair_delimiter       = '=';

   kvp_type kvp(options);

   data_store ds;

   kvp.register_keyvalue(121, ds.  c);
   kvp.register_keyvalue(122, ds. uc);
   kvp.register_keyvalue(123, ds.  s);
   kvp.register_keyvalue(124, ds. us);
   kvp.register_keyvalue(125, ds.  i);
   kvp.register_keyvalue(126, ds.str);

   kvp(data);

   return 0;
}
                       </pre>

                       <h3 align="left"><a name="OptionalKeyValuePairs">Optional Key-Value Pairs</a></h3>
                       <p align="left">
                        As previously mentioned there is a use-case where certain fields may
                        be deemed optional and hence their absence would not constitute a
                        parsing error. That said, it would also be beneficial to know if a
                        particular field has been populated or not once the sequence of key
                        value pairs has been completely parsed and mapped. StrTk provides such
                        functionality though the use of the strtk::util::attribute type.<br> <br>

                        The <b>strtk::util::attribute</b> acts as a proxy for the underlying type
                        which it is specialized upon. It provides a conversion cast to the
                        underlying type, and also maintains an 'initialised' state value that
                        can be used to query the attribute about the underlying type's
                        initialised status. The following is an example of how one could use
                        the <b>strtk::util::attribute</b> type in conjunction with the
                        keyvalue::parser:
                       </p>

                       <pre>
struct data_store
{
   strtk::util::attribute&lt;int&gt; d1;
   strtk::util::attribute&lt;unsigned int&gt; d2;
   strtk::util::attribute&lt;double&gt; d3;
   strtk::util::attribute&lt;float&gt; d4;
   strtk::util::attribute&lt;std::string&gt; d5;
};

int main()
{
   std::string data = "INT=-1234|UINT=+5678|DOUBLE=1234.5678|"
                      "FLOAT=90123.4567f|STRING=Some simple text";

   typedef unsigned char char_type;
   typedef strtk::keyvalue::parser&lt;strtk::keyvalue::stringkey_map&gt; kvp_type;
   typedef strtk::keyvalue::options&lt;char_type&gt; opts_type;

   opts_type options;

   options.pair_block_delimiter = '|';
   options.pair_delimiter       = '=';

   kvp_type kvp(options);

   data_store ds;

   d1.initialised() = false;
   d2.initialised() = false;
   d3.initialised() = false;
   d4.initialised() = false;
   d5.initialised() = false;

   kvp.register_keyvalue("INT"   , ds.d1);
   kvp.register_keyvalue("UINT"  , ds.d2);
   kvp.register_keyvalue("DOUBLE", ds.d3);
   kvp.register_keyvalue("FLOAT" , ds.d4);
   kvp.register_keyvalue("STRING", ds.d5);

   if (!kvp(data))
   {
      std::cout &lt;&lt; "Failed to parse key-value data: " &lt;&lt; data &lt;&lt; std::endl;
      return 1;
   }

   if (!d1.initialised()) { std::cout &lt;&lt; "d1 has not been initialised." &lt;&lt; std::endl; }
   if (!d2.initialised()) { std::cout &lt;&lt; "d2 has not been initialised." &lt;&lt; std::endl; }
   if (!d3.initialised()) { std::cout &lt;&lt; "d3 has not been initialised." &lt;&lt; std::endl; }
   if (!d4.initialised()) { std::cout &lt;&lt; "d4 has not been initialised." &lt;&lt; std::endl; }
   if (!d5.initialised()) { std::cout &lt;&lt; "d5 has not been initialised." &lt;&lt; std::endl; }

   return 0;
}
                       </pre>


                       <h3 align="left"><a name="SemanticActionsWithKeyValuePairs">Semantic Actions With Key-Value Pairs</a></h3>
                       <p align="left">
                        There may be times that when key-value pairs are being parsed certain
                        actions need to be executed or behaviours exhibited in-situ with the
                        parsing process. As previously mentioned, StrTk provides the type
                        semantic_action that can act as a proxy for a generic type during the
                        parsing process that also takes a functor or lambda and executes it at
                        the conversion call. The following example demonstrates the parsing of
                        an array of tuples comprised of key-value pairs that map to members of
                        a struct namely data_store. The keys 111, 222 and 333 each represent a
                        specific value type, they also require a certain behavior to be
                        exhibited. In this example, for simplicity, as the values of the
                        various keys are being parsed, a simple message will be printed to the
                        console denoting the nature of the parsing process. The code is as
                        follows:
                       </p>

                       <pre>struct data_store
{
   data_store()
   : i1(0),
     d1(0.0),
     s1("")
   {}

   int         i1; // key = 111
   double      d1; // key = 222
   std::string s1; // key = 333

};

int main()
{
   static const std::string data[] =
                      {
                         "111=-12345|222=1987.654321|333=An interesting string0", // Tuple0
                         "222=2987.654321|333=An interesting string1|111=+12345", // Tuple1
                         "333=An interesting string2|111=-12345|222=3987.654321", // Tuple2
                         "222=4987.654321|111=+12345|333=An interesting string3", // Tuple3
                         "333=An interesting string4|222=5987.654321|111=-12345", // Tuple4
                         "111=+12345|333=An interesting string5|222=6987.654321", // Tuple5
                      };

   static const std::size_t data_size = sizeof(data) / sizeof(std::string);

   typedef strtk::keyvalue::parser&lt;strtk::keyvalue::uintkey_map&gt; kvp_type;

   strtk::keyvalue::uintkey_map::options options;

   options.key_count            = 334; // [111,333]
   options.pair_block_delimiter = '|';
   options.pair_delimiter       = '=';

   kvp_type kvp(options);

   data_store ds;

   typedef strtk::range::ustring::const_iterator itr_type;
   using strtk::util::semantic_action;

   // Parsing action for key 111
   auto lambda_key111 = [&amp;ds](itr_type begin,itr_type end) -&gt; bool
                        {
                           if (!strtk::string_to_type_converter(begin, end, ds.i1))
                           {
                              std::cout &lt;&lt; "Failed to parse value for key=111\n";

                              return false;
                           }

                           std::cout &lt;&lt; "key[111] value=" &lt;&lt; ds.i1 &lt;&lt; std::endl;

                           return true;
                        };

   // Parsing action for key 222
   auto lambda_key222 = [&amp;ds](itr_type begin,itr_type end) -&gt; bool
                        {
                           if (!strtk::string_to_type_converter(begin, end, ds.d1))
                           {
                              std::cout &lt;&lt; "Failed to parse value for key=222\n";

                              return false;
                           }

                           std::cout &lt;&lt; "key[222] value=" &lt;&lt; ds.d1 &lt;&lt; std::endl;

                           return true;
                        };

   // Parsing action for key 333
   auto lambda_key333 = [&amp;ds](itr_type begin,itr_type end) -&gt; bool
                        {
                           if (!strtk::string_to_type_converter(begin, end, ds.s1))
                           {
                              std::cout &lt;&lt; "Failed to parse value for key=333\n";

                              return false;
                           }

                           std::cout &lt;&lt; "key[333] value=" &lt;&lt; ds.s1 &lt;&lt; std::endl;

                           return true;
                        };

   kvp.register_keyvalue(111,semantic_action(lambda_key111).ref());
   kvp.register_keyvalue(222,semantic_action(lambda_key222).ref());
   kvp.register_keyvalue(333,semantic_action(lambda_key333).ref());

   for (std::size_t i = 0; i &lt; data_size; ++i)
   {
      if (!kvp(data[i]))
         std::cout &lt;&lt; "Error while parsing tuple: " &lt;&lt; i &lt;&lt; std::endl;

      std::cout &lt;&lt; std::endl;
   }

   return 0;
}
                       </pre>

                       <p align="left">
                        <b>Note:</b> It should be noted that semantic actions during the
                        parsing process have a multitude of uses, some of which are:
                        validation of parsed values, that is making sure that they're in a
                        specified range or within a predefined set of values, complex parsed
                        value manipulations, invoking of external state-machines to transition
                        to new states based on the parsed value or even simply the presence of
                        a key etc.
                       </p>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="AnAttemptAtImprovingFileProcessingPerformance">An Attempt At Improving File Processing Performance</a></h3>
                       <p align="left">
                        In a number of examples from above, a call to strtk::for_each_line was
                        invoked. The routine is intended to provide a simple wrapper around
                        the error prone boiler plate code that is required when processing a
                        text file line by line.<br> <br>

                        The idea behind strtk::for_each_line is that the user provide a
                        lambda/functor that accepts a std::string, the routine will in turn
                        invoke the lambda passing the current line it has read from the file,
                        all other details related to opening of the file, reading lines from
                        the file and the handling of errors are transparent to the user
                        specified lambda.<br> <br>

                        For most situations this is perfectly fine, however for certain types
                        of high performance data processing, the overhead incurred from
                        std::ifstream <em>(virtual method calls on a per char basis, multiple
                        copies due to back buffers etc)</em> via the invocation of std::getline,
                        result in an unacceptable performance profile.<br> <br>

                        Due to the simple nature of the I/O access pattern (forward only)
                        utilized within strtk::for_each_line, a memory mapped file approach
                        would be far more efficient, being roughly <b>5x-7x</b> faster than
                        the standard <b>strtk::for_each_line</b> routine. The following is
                        a simple example of code that utilises the Boost.IOStreams mmap facility
                        namely: mapped_file_source for mmap'ing the user specified file in
                        conjunction with strtk::split to delimit on line boundaries that are
                        denoted by new-line characters.
                       </p>

                       <pre>namespace strtk
{
   template &lt;typename Function&gt;
   std::size_t for_each_line_mmap(const std::string&amp; file_name,
                                  Function function,
                                  const std::size_t&amp;
                                  buffer_size = one_kilobyte)
   {
      boost::iostreams::mapped_file_source input_source;

      try
      {
         input_source.open(file_name);
      }
      catch (std::exception&amp;)
      {
         return 0;
      }

      const char* data = input_source.data();

      multiple_char_delimiter_predicate delimiter("\n");

      std::string buffer;
      buffer.reserve(buffer_size);
      std::size_t line_count = 0;

      split(delimiter,
            data, data + input_source.size(),
            functional_inserter(
               [&amp;](const range::string&amp; range)
               {
                  if (range.begin() == range.end())
                     return;

                  const char* end = range.end();

                  if (line_count &amp;&amp; ('\r' == *(end - 1)))
                     end--;

                  buffer.assign(range.begin(),end);

                  function(buffer);

                  ++line_count;
               }),
            split_options::compress_delimiters);

      return line_count;
   }
}

                       </pre>

                       <p align="left">
                        <b>Note:</b> The following are some points to consider with the solution presented above:<br>

                        </p><ul style="text-align: left">
                        <li>
                         Because the routine attempts to map the entire file, on 32-bit systems
                         this may fail when the file is very large, due to the limited availability
                         of virtual address space. This can be easily remedied by windowing the
                         mmap access over the file.
                        </li>
                        <li>
                         If the system is under heavy load memory-wise, the performance
                         observed is expected to be similar to but no worse than if the
                         original strtk::for_each_line routine were used.
                        </li>
                        <li>
                         The interface with the lambda can be improved to instead only pass a
                         range rather than to populate and pass a std::string as is done when
                         using std::getline. This improvement results in a roughly 5% increase
                         in performance.
                        </li>
                        <li>
                         An interesting side effect of the range based approached, is that the
                         ranges denote the exact offsets from the original file for the begin
                         and end positions of the string currently being processed. This can be
                         very useful in situations where the exact location of a token is
                         required post processing - as is the case with the problem presented
                         earlier: "Pick A Random Line From A Text File"
                        </li>
                        </ul>
                       <p></p>

                       <h3 align="left"><a name="MMapBenchmark">MMap Benchmark using 'strtk::for_each_line'</a></h3>
                       <p align="left">
                        The following benchmark demonstrates all three variations of
                        <b>strtk::for_each_line</b> routine, which include normal,
                        mmap+std::string and mmap+ranges. The example, iterates through
                        a file of roughly 825MB in size, comprised of two types of CSV
                        lines, each containing 100 tokens, where some of the tokens are
                        to be parsed as integers. Each line is parsed, the integers
                        extracted as necessary and then accumulated into a final sum
                        so as to minimize any aggressive optimizations.<br><br>

                        <a href="http://www.partow.net/programming/strtk/data/strtk_mmap_test.cpp"><b>Download Memory-Mapped File Benchmark</b></a><br><br>
                       </p>

                       <p align="left">
                        The following is a set of results derived from a run of the above
                        benchmark, based on a build using GCC 4.8, with O2 and PGO, running
                        on a Xeon X5650 3.2GHz 64GB RAM, kernel 3.11. The base measure is lines
                        processed per second. The greater the value the <em><b>higher</b></em>
                        the performance.
                       </p>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_mmap_chart.png" alt="C++ String Toolkit Library Memory-Mapped File Benchmark - Copyright Arash Partow" border="0">
                       </p>


                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr><th class="tg-031e">Method</th><th class="tg-031e">Lines/sec</th></tr>
                         <tr><td class="tg-031e">Standard  </td><td class="tg-031e">126817</td></tr>
                         <tr><td class="tg-031e">MMap      </td><td class="tg-031e">710317</td></tr>
                         <tr><td class="tg-yw4l">MMap+Range</td><td class="tg-yw4l">735317</td></tr>
                       </tbody></table>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="TheLettersGame">The Letters Game</a></h3>
                       <p align="left">
                        In the popular TV game show Countdown (aka Letters and Numbers),
                        contestants in the Letters round take turns choosing letters from
                        either a vowel or consonant bin. Typically up to 9 letters are chosen,
                        after which the contestants are given a certain amount of time
                        (usually 30 seconds) to find the longest 'valid' English word made up
                        of only the letters that had been chosen. The contestant with the
                        longest valid word wins the round. What defines a valid word is
                        usually specific to the version of the show. Some examples are using
                        the OED or the Macquarie dictionary coupled together with rules
                        related to proper nouns, plurals and combination words. The Letters
                        round is essentially an anagram solving challenge.<br><br>

                        The Letters game can be generally defined as: Given a canonical set of
                        substrings of varying length called C, generated from the alphabet A,
                        and a subset of not necessarily unique elements derived from A called
                        D, find the longest substring in the set C that is also in the set of
                        the 2<sup>|D|</sup> unique combinations generated from the set D.<br><br>

                        A typical process for solving the Letters problem is as follows:
                       </p>

                       <ul style="text-align: left">
                       <li>
                        <b>Step 0</b> - A list of unique valid words is specified <em>(eg: OED or Word List)</em><br>

                        <ul style="text-align: left">
                        <li> <b>Step 0.0</b> - The longest word length from the list of words is noted as being L </li>
                        <li> <b>Step 0.1</b> - Each word is normalised to a common case. <em>(eg: all lower case)</em> </li>
                        <li> <b>Step 0.2</b> - Store the length of the words into a "word length" set </li>
                        </ul>
                       </li>

                       <li> <b>Step 1</b> - For every word w<sub>i</sub>, generate the key k<sub>i</sub> by sorting the letters of the word. <em>(eg: For the word 'english', the key 'eghilns' is derived)</em> </li>

                       <li> <b>Step 2</b> - Insert each key/word pair into an associative map M <em>(eg: hash-table)</em> </li>

                       <li>
                        <b>Step 3</b> - A list of potentially non-unique letters of length N is specified comprised of both consonants and vowels<br>
                        <ul style="text-align: left">
                        <li><b>Step 3.0</b> - Lexicographically order this list of letters</li>
                        </ul>
                       </li>

                       <li>
                        <b>Step 4</b> - For every N-choose-K combinations over the list of N letters, where K starts from min(L,N) and tends to 1:
                        <ul style="text-align: left">
                        <li><b>Step 4.0</b> - If no words of length K exist proceed to the next value of K</li>
                        <li><b>Step 4.1</b> - Test the current combination x as a key in M</li>
                        <li><b>Step 4.2</b> - If x exists in M, add all the words associated with x into a solution list S</li>
                        <li><b>Step 4.3</b> - Otherwise continue on with the next combinations and values of K</li>
                        <li><b>Step 4.4</b> - Once all the combinations for the current I have been enumerated present the solution list S - <em>(if it is not empty)</em></li>
                        </ul>
                       </li>
                       </ul>

                       <pre>
int main()
{
   std::string word_list_file_name = "word_list.txt";

   typedef std::unordered_multimap&lt;std::string,std::string&gt; word_map_t;
   typedef std::pair&lt;word_map_t::iterator,word_map_t::iterator&gt; word_map_range_t;

   word_map_t word_map;
   std::set&lt;unsigned int&gt; word_length;

   std::size_t longest_word = 0;

   // Load the word map as per steps 0 and 1
   strtk::for_each_line(word_list_file_name,
                        [&amp;](std::string word)
                        {
                           if (word.empty()) return;

                           strtk::remove_leading_trailing(" \t\n\r",word);

                           // Generate the key for the specified word.
                           strtk::convert_to_lowercase(word);
                           std::string key = word;
                           strtk::sort(key);

                           word_map.insert(std::make_pair(key,word));

                           longest_word = std::max(longest_word,word.size());

                           word_length.insert(word.size());
                        });

   std::string letters;

   for (;;)
   {
      // Load, prepare and validate the game letters
      std::cout &lt;&lt; "Enter letters: ";
      if(!std::getline(std::cin,letters))
         break;

      static const std::string illegal_chars = strtk::ext_string::all_chars() -
                                               strtk::ext_string::all_letters();

      strtk::multiple_char_delimiter_predicate pred(illegal_chars);

      strtk::remove_inplace(pred,letters);

      if (letters.empty()) break;

      strtk::convert_to_lowercase(letters);
      strtk::sort(letters);

      const std::size_t upper_bound = std::min(longest_word, letters.size());

      std::unordered_set&lt;std::string&gt; solution_list;

      for (std::size_t i = upper_bound; i &gt; 0; --i)
      {
         if (word_length.end() == word_length.find(i))
            continue;

         typedef std::string::iterator str_itr_t;

         // Enumerate all N-choose-I combinations as per step 4
         strtk::for_each_combination(letters.begin(), letters.end(),
                                     i,
                                     [&amp;](str_itr_t begin, str_itr_t end)
                                     {
                                        std::string key(begin,end);

                                        word_map_range_t itr_range = word_map.equal_range(key);

                                        if (0 == strtk::distance(itr_range)) return;

                                        auto itr = itr_range.first;

                                        while (itr_range.second != itr)
                                        {
                                           solution_list.insert(itr-&gt;second);
                                           ++itr;
                                        }
                                    });

         // Present the solution list if solutions have been found as per step 4.4
         if (!solution_list.empty())
         {
            std::copy(solution_list.begin(),
                      solution_list.end(),
                      std::ostream_iterator&lt;std::string&gt;(std::cout,"\n"));
            break;
         }
      }
   }

   return 0;
}
                       </pre>

                       <h3 align="left">Notes On The Letters Round Solution</h3>
                       <p align="left">
                        The time complexity of the given solution is <b>O(2<sup>min(L,N)</sup>)</b>,
                        which is quite large. What makes the solution practical, is the fact
                        that natural languages such as English tend to have short common words
                        derived from relatively small alphabets, with an upper range length of
                        about length 10-12 characters <em>(excluding names et al and of course
                        Pneumonoultramicroscopicsilicovolcanoconiosis)</em>. So for example an
                        N of 10 or even 20 <em>(assuming L is adequately large)</em>, will only
                        amount to a total of 1024 and 1048576 unique combinations respectively -
                        furthermore both search spaces can be trivially enumerated using brute
                        force in a mere fraction of a millisecond using modern hardware.<br><br>

                        However the problem space becomes daunting at around N of 64 and larger.
                        At which point a constant multiplier can be applied by distributing the
                        enumeration process and performing said computations concurrently. Note
                        this will not reduce the overall complexity of the solution, just the
                        time it will take to complete, furthermore today this technique may only
                        be practical for values of N less than 67.<br><br>

                        One final note, the above process will not only provide the first
                        solution it encounters, it will return all possible solutions for
                        largest encountered length combination.
                       </p>

                       <h3 align="left">Past Letters Round Games</h3>
                       <p align="left">
                        The following is a short list of the Letters round games played on
                        countdown during the 2010 season.
                       </p>

                       <pre>
TSDTOEIRO DELAWERAD FSGTIOAOV LESADEPIL YTAINROTD LLBUEISUT GEMUHRONA TRNSEAENI
BPSQEAEVN GOXERAMJA NTRTIOAEP FLUENTLIP SCRSIEONU HPAVSOEDA WKCJROEAM IGTYEARTN
DSOEXDALM SMNRIEIUG EFCAORTNA HGRNEOITE RGPNIEUQA TREULDEOF SNRTEUIDA TRUCEENDS
HTNXIUOAD TREULDEOF SNRTEUIDA TRUCEENDS HTNXIUOAD SWDEIUHBE NWCKPAIAE NYDAOUTAU
SGLAEOMVI GLQGEIODV RTLEOESTI JCRRUAEOS LSDSEAEFO TRMAEASRI NFRNOIAES BROADMOOR
                       </pre>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="PerformanceComparisons">Performance Comparisons</a></h3>
                       <p align="left">
                        The following are tables of results generated by running the
                        strtk_tokenizer_cmp test. Currently it covers simple comparisons
                        between Boost String Algorithms, Boost lexical_cast, The Standard
                        Library, Spirit (Karma Qi) and StrTk in the following areas:
                       </p>

                        <ul style="text-align: left">
                        <li>Tokenization     </li>
                        <li>Splitting        </li>
                        <li>Integer To String</li>
                        <li>String To Integer</li>
                        <li>String To Double </li>
                        </ul>

                       <h4 align="left">Scenario 0 - MSVC 2010 (64-bit, O2, Ot, GL and PGO)</h4>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-804w{font-family:Arial, Helvetica, sans-serif !important;;text-align:center;vertical-align:top}
                       .tg .tg-hgcj{font-weight:bold;text-align:center}
                       .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr>
                           <th class="tg-hgcj">Source</th>
                           <th class="tg-hgcj">Test</th>
                           <th class="tg-amwm">Size</th>
                           <th class="tg-amwm">Time(sec)</th>
                           <th class="tg-amwm">Rate</th>
                           <th class="tg-amwm">% from Baseline</th>
                         </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l">8.5857sec  </td>    <td class="tg-yw4l"> 2795359.4074tks/sec </td> <td class="tg-yw4l">100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-031e">StrTk  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l">3.5019sec  </td>    <td class="tg-yw4l">6853393.1186tks/sec  </td> <td class="tg-yw4l">40.7%, 245.1%  </td> </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">5.5414sec  </td>    <td class="tg-yw4l">1732414.5137tks/sec  </td> <td class="tg-yw4l">100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">0.8218sec  </td>    <td class="tg-yw4l">11681814.9167tks/sec </td> <td class="tg-yw4l">14.8%, 674.3%  </td> </tr>
                         <tr><td class="tg-yw4l">sprintf</td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">35.8128sec </td>    <td class="tg-yw4l">2233840.0564nums/sec </td> <td class="tg-yw4l">100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">19.3994sec </td>    <td class="tg-yw4l">4123832.0477nums/sec </td> <td class="tg-yw4l">54.1%, 184.6%  </td> </tr>
                         <tr><td class="tg-yw4l">Karma  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">6.2528sec  </td>    <td class="tg-yw4l">12794349.6524nums/sec</td> <td class="tg-yw4l">17.4%, 572.7%  </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">1.5664sec  </td>    <td class="tg-yw4l">51071439.9822nums/sec</td> <td class="tg-yw4l">4.3%, 2286.2%  </td> </tr>
                         <tr><td class="tg-yw4l">atoi   </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">5.1802sec  </td>    <td class="tg-yw4l">17084370.4936nums/sec</td> <td class="tg-yw4l">100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">119.6261sec</td>    <td class="tg-yw4l">739805.3712nums/sec  </td> <td class="tg-yw4l">2309.2%, 4.3%  </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">2.1951sec  </td>    <td class="tg-yw4l">40317238.6629nums/sec</td> <td class="tg-yw4l">42.3%, 235.9%  </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">1.8181sec  </td>    <td class="tg-yw4l">48677773.5466nums/sec</td> <td class="tg-yw4l">35.0%, 284.9%  </td> </tr>
                         <tr><td class="tg-yw4l">atof   </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">15.2306sec </td>    <td class="tg-yw4l">2012396.7122nums/sec </td> <td class="tg-yw4l">100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">52.9244sec </td>    <td class="tg-yw4l">579127.8866nums/sec  </td> <td class="tg-yw4l">347.4%, 28.7%  </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">2.8665sec  </td>    <td class="tg-yw4l">10692313.5853nums/sec</td> <td class="tg-yw4l">18.8%, 531.3%  </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">1.6069sec  </td>    <td class="tg-yw4l">19073975.7679nums/sec</td> <td class="tg-yw4l">10.5%, 947.8%  </td> </tr>
                       </tbody></table>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_msvc10_64bit_chart.png" alt="C++ String Toolkit Library MSVC 2010 Chart - Copyright Arash Partow" border="0">
                       </p>

                       <h4 align="left">Scenario 1 - MSVC 2010 (O2, Ot, GL and PGO)</h4>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-804w{font-family:Arial, Helvetica, sans-serif !important;;text-align:center;vertical-align:top}
                       .tg .tg-hgcj{font-weight:bold;text-align:center}
                       .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr>
                           <th class="tg-hgcj">Source</th>
                           <th class="tg-hgcj">Test</th>
                           <th class="tg-amwm">Size</th>
                           <th class="tg-amwm">Time(sec)</th>
                           <th class="tg-amwm">Rate</th>
                           <th class="tg-amwm">% from Baseline</th>
                         </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l">  9.4715sec</td> <td class="tg-yw4l">  2533910.4769tks/sec</td> <td class="tg-yw4l"> 100.0%,  100.0%</td> </tr>
                         <tr><td class="tg-031e">StrTk  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l">  2.8889sec</td> <td class="tg-yw4l">  8307786.9292tks/sec</td> <td class="tg-yw4l">  30.5%,  327.8%</td> </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">  7.2291sec</td> <td class="tg-yw4l">  1327965.9706tks/sec</td> <td class="tg-yw4l"> 100.0%,  100.0%</td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">  1.1301sec</td> <td class="tg-yw4l">  8494610.9664tks/sec</td> <td class="tg-yw4l">  15.6%,  639.6%</td> </tr>
                         <tr><td class="tg-yw4l">sprintf</td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l"> 38.2576sec</td> <td class="tg-yw4l"> 2091088.8038nums/sec</td> <td class="tg-yw4l"> 100.0%,  100.0%</td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l"> 28.9931sec</td> <td class="tg-yw4l"> 2759277.4769nums/sec</td> <td class="tg-yw4l">  75.7%,  131.9%</td> </tr>
                         <tr><td class="tg-yw4l">Karma  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">  4.9173sec</td> <td class="tg-yw4l">16269254.0190nums/sec</td> <td class="tg-yw4l">  12.8%,  778.0%</td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">  1.8270sec</td> <td class="tg-yw4l">43786838.0279nums/sec</td> <td class="tg-yw4l">   4.7%, 2093.9%</td> </tr>
                         <tr><td class="tg-yw4l">atoi   </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">  6.0076sec</td> <td class="tg-yw4l">14731435.8942nums/sec</td> <td class="tg-yw4l"> 100.0%,  100.0%</td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">185.4955sec</td> <td class="tg-yw4l">  477100.6474nums/sec</td> <td class="tg-yw4l">3087.0%,    3.2%</td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">  2.5060sec</td> <td class="tg-yw4l">35314785.8370nums/sec</td> <td class="tg-yw4l">  41.7%,  239.7%</td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">  2.2095sec</td> <td class="tg-yw4l">40054213.0736nums/sec</td> <td class="tg-yw4l">  36.7%,  271.8%</td> </tr>
                         <tr><td class="tg-yw4l">atof   </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l"> 17.6435sec</td> <td class="tg-yw4l"> 1737179.9302nums/sec</td> <td class="tg-yw4l"> 100.0%,  100.0%</td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l"> 78.6528sec</td> <td class="tg-yw4l">  389687.3997nums/sec</td> <td class="tg-yw4l"> 445.7%,  22.4% </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">  3.8034sec</td> <td class="tg-yw4l"> 8058494.1994nums/sec</td> <td class="tg-yw4l">  21.5%,  463.8%</td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">  2.0450sec</td> <td class="tg-yw4l">14987780.2310nums/sec</td> <td class="tg-yw4l">  11.5%,  862.7%</td> </tr>
                       </tbody></table>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_msvc10_chart.png" alt="C++ String Toolkit Library MSVC 2010 Chart - Copyright Arash Partow" border="0">
                       </p>


                       <h4 align="left">Scenario 2 - MSVC 2008 SP1 (O2, Ot, GL and PGO)</h4>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-804w{font-family:Arial, Helvetica, sans-serif !important;;text-align:center;vertical-align:top}
                       .tg .tg-hgcj{font-weight:bold;text-align:center}
                       .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr>
                           <th class="tg-hgcj">Source</th>
                           <th class="tg-hgcj">Test</th>
                           <th class="tg-amwm">Size</th>
                           <th class="tg-amwm">Time(sec)</th>
                           <th class="tg-amwm">Rate</th>
                           <th class="tg-amwm">% from Baseline</th>
                         </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l"> 9.6533sec </td> <td class="tg-yw4l"> 2486184.8282tks/sec </td> <td class="tg-yw4l"> 100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-031e">StrTk  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l">3.4748sec  </td> <td class="tg-yw4l">6906943.9529tks/sec  </td> <td class="tg-yw4l">  35.9%, 277.8% </td> </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">10.2600sec </td> <td class="tg-yw4l">935674.7490tks/sec   </td> <td class="tg-yw4l"> 100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">1.3793sec  </td> <td class="tg-yw4l">6959830.0652tks/sec  </td> <td class="tg-yw4l">  13.4%, 743.8% </td> </tr>
                         <tr><td class="tg-yw4l">sprintf</td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">24.6427sec </td> <td class="tg-yw4l">3246397.8287nums/sec </td> <td class="tg-yw4l"> 100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">27.5865sec </td> <td class="tg-yw4l">2899968.5753nums/sec </td> <td class="tg-yw4l"> 111.9%,  89.3% </td> </tr>
                         <tr><td class="tg-yw4l">Karma  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">5.4864sec  </td> <td class="tg-yw4l">14581630.6963nums/sec</td> <td class="tg-yw4l">  22.2%, 449.1% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">2.4224sec  </td> <td class="tg-yw4l">33025441.1256nums/sec</td> <td class="tg-yw4l">   9.8%,1017.2% </td> </tr>
                         <tr><td class="tg-yw4l">atoi   </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">5.9297sec  </td> <td class="tg-yw4l">14924814.8683nums/sec</td> <td class="tg-yw4l"> 100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">186.1372sec</td> <td class="tg-yw4l">475455.6660nums/sec  </td> <td class="tg-yw4l">3139.0%,   3.1% </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">2.0874sec  </td> <td class="tg-yw4l">42397446.1804nums/sec</td> <td class="tg-yw4l">  35.2%, 284.0% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">2.0485sec  </td> <td class="tg-yw4l">43202160.1371nums/sec</td> <td class="tg-yw4l">  34.5%, 289.4% </td> </tr>
                         <tr><td class="tg-yw4l">atof   </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">18.0458sec </td> <td class="tg-yw4l">1698455.0767nums/sec </td> <td class="tg-yw4l"> 100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">77.4527sec </td> <td class="tg-yw4l">395725.4111nums/sec  </td> <td class="tg-yw4l"> 429.2%,  23.2% </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">3.9631sec  </td> <td class="tg-yw4l">7733881.1294nums/sec </td> <td class="tg-yw4l">  21.9%, 455.3% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">2.0723sec  </td> <td class="tg-yw4l">14790236.0804nums/sec</td> <td class="tg-yw4l">  11.4%, 870.8% </td> </tr>
                       </tbody></table>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_msvc9_chart.png" alt="C++ String Toolkit Library MSVC 2008 Chart - Copyright Arash Partow" border="0">
                       </p>


                       <h4 align="left">Scenario 3 - Intel C++ v11.1.060 IA-32 (O2, Ot, Qipo, QxHost and PGO)</h4>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-804w{font-family:Arial, Helvetica, sans-serif !important;;text-align:center;vertical-align:top}
                       .tg .tg-hgcj{font-weight:bold;text-align:center}
                       .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr>
                           <th class="tg-hgcj">Source</th>
                           <th class="tg-hgcj">Test</th>
                           <th class="tg-amwm">Size</th>
                           <th class="tg-amwm">Time(sec)</th>
                           <th class="tg-amwm">Rate</th>
                           <th class="tg-amwm">% from Baseline</th>
                         </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l">10.0096sec </td> <td class="tg-yw4l"> 2397697.7836tks/sec </td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-031e">StrTk  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l">3.1837sec  </td> <td class="tg-yw4l">7538416.8541tks/sec  </td> <td class="tg-yw4l">31.8%, 314.4% </td> </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">9.5450sec  </td> <td class="tg-yw4l">1005760.0310tks/sec  </td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">1.4292sec  </td> <td class="tg-yw4l">6716893.1359tks/sec  </td> <td class="tg-yw4l">14.9%, 667.8% </td> </tr>
                         <tr><td class="tg-yw4l">sprintf</td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">23.8979sec </td> <td class="tg-yw4l">3347577.5824nums/sec </td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">27.5618sec </td> <td class="tg-yw4l">2902565.2045nums/sec </td> <td class="tg-yw4l">115.3%, 86.7% </td> </tr>
                         <tr><td class="tg-yw4l">Karma  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">4.6600sec  </td> <td class="tg-yw4l">17167208.7654nums/sec</td> <td class="tg-yw4l">19.4%, 512.8% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">2.8450sec  </td> <td class="tg-yw4l">28119857.2736nums/sec</td> <td class="tg-yw4l">11.9%, 840.0% </td> </tr>
                         <tr><td class="tg-yw4l">atoi   </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">5.9386sec  </td> <td class="tg-yw4l">14902610.8922nums/sec</td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">180.5856sec</td> <td class="tg-yw4l">490072.4001nums/sec  </td> <td class="tg-yw4l">3040.8%, 3.2% </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">2.5273sec  </td> <td class="tg-yw4l">35017073.8639nums/sec</td> <td class="tg-yw4l">42.5%, 234.9% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">1.8718sec  </td> <td class="tg-yw4l">47281492.1287nums/sec</td> <td class="tg-yw4l">31.5%, 317.2% </td> </tr>
                         <tr><td class="tg-yw4l">atof   </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">18.4357sec </td> <td class="tg-yw4l">1662538.0810nums/sec </td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">78.1543sec </td> <td class="tg-yw4l">392172.9598nums/sec  </td> <td class="tg-yw4l">423.9%, 23.5% </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">2.8321sec  </td> <td class="tg-yw4l">10822353.0510nums/sec</td> <td class="tg-yw4l">15.3%, 650.9% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">2.2930sec  </td> <td class="tg-yw4l">13366541.5515nums/sec</td> <td class="tg-yw4l">12.4%, 803.9% </td> </tr>
                       </tbody></table>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_intel11_chart.png" alt="C++ String Toolkit Library Intel Compiler v11 Chart - Copyright Arash Partow" border="0">
                       </p>


                       <h4 align="left">Scenario 4 - GCC 4.5 (O3, PGO)</h4>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-804w{font-family:Arial, Helvetica, sans-serif !important;;text-align:center;vertical-align:top}
                       .tg .tg-hgcj{font-weight:bold;text-align:center}
                       .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr>
                           <th class="tg-hgcj">Source</th>
                           <th class="tg-hgcj">Test</th>
                           <th class="tg-amwm">Size</th>
                           <th class="tg-amwm">Time(sec)</th>
                           <th class="tg-amwm">Rate</th>
                           <th class="tg-amwm">% from Baseline</th>
                         </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l"> 9.2510sec</td> <td class="tg-yw4l"> 2594305.4347tks/sec </td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-031e">StrTk  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l">3.9717sec </td> <td class="tg-yw4l">6042688.5734tks/sec  </td> <td class="tg-yw4l">42.9%, 232.9% </td> </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">5.0640sec </td> <td class="tg-yw4l">1895728.2331tks/sec  </td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">1.5411sec </td> <td class="tg-yw4l">6229231.8384tks/sec  </td> <td class="tg-yw4l">30.4%, 328.5% </td> </tr>
                         <tr><td class="tg-yw4l">sprintf</td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">14.7807sec</td> <td class="tg-yw4l">5412477.0993nums/sec </td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">19.1131sec</td> <td class="tg-yw4l">4185620.7707nums/sec </td> <td class="tg-yw4l">129.3%, 77.3% </td> </tr>
                         <tr><td class="tg-yw4l">Karma  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">6.4455sec </td> <td class="tg-yw4l">12411808.2841nums/sec</td> <td class="tg-yw4l">43.6%, 229.3% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">4.5174sec </td> <td class="tg-yw4l">17709364.5349nums/sec</td> <td class="tg-yw4l">30.5%, 327.1% </td> </tr>
                         <tr><td class="tg-yw4l">atoi   </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">5.2139sec </td> <td class="tg-yw4l">16973721.6103nums/sec</td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">50.5326sec</td> <td class="tg-yw4l">1751344.8498nums/sec </td> <td class="tg-yw4l">969.1%, 10.3% </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">1.9694sec </td> <td class="tg-yw4l">44937612.8835nums/sec</td> <td class="tg-yw4l">37.7%, 264.7% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">1.9008sec </td> <td class="tg-yw4l">46558706.5833nums/sec</td> <td class="tg-yw4l">36.4%, 274.2% </td> </tr>
                         <tr><td class="tg-yw4l">atof   </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">6.6975sec </td> <td class="tg-yw4l">4576328.3036nums/sec </td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">29.6375sec</td> <td class="tg-yw4l">1034162.2422nums/sec </td> <td class="tg-yw4l">442.5%, 22.5% </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">2.9852sec </td> <td class="tg-yw4l">10267435.7138nums/sec</td> <td class="tg-yw4l">44.5%, 224.3% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">1.5961sec </td> <td class="tg-yw4l">19202937.1409nums/sec</td> <td class="tg-yw4l">23.8%, 419.6% </td> </tr>
                       </tbody></table>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_gcc4_chart.png" alt="C++ String Toolkit Library GCC v4 Chart - Copyright Arash Partow" border="0">
                       </p>


                       <h4 align="left">Scenario 5 - GCC 4.5 (O3, PGO) Intel Atom N450</h4>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-804w{font-family:Arial, Helvetica, sans-serif !important;;text-align:center;vertical-align:top}
                       .tg .tg-hgcj{font-weight:bold;text-align:center}
                       .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr>
                           <th class="tg-hgcj">Source</th>
                           <th class="tg-hgcj">Test</th>
                           <th class="tg-amwm">Size</th>
                           <th class="tg-amwm">Time(sec)</th>
                           <th class="tg-amwm">Rate</th>
                           <th class="tg-amwm">% from Baseline</th>
                         </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l"> 29.1370sec</td> <td class="tg-yw4l"> 823695.4389tks/sec  </td> <td class="tg-yw4l"> 100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-031e">StrTk  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l">12.3607sec </td> <td class="tg-yw4l">1941644.0499tks/sec  </td> <td class="tg-yw4l">42.4%, 235.7%  </td> </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">16.5261sec </td> <td class="tg-yw4l">580899.9726tks/sec   </td> <td class="tg-yw4l">100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">4.9102sec  </td> <td class="tg-yw4l">1955110.2611tks/sec  </td> <td class="tg-yw4l">29.7%, 336.5%  </td> </tr>
                         <tr><td class="tg-yw4l">sprintf</td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">50.3456sec </td> <td class="tg-yw4l">1589015.6118nums/sec </td> <td class="tg-yw4l">100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">91.1475sec </td> <td class="tg-yw4l">877698.1401nums/sec  </td> <td class="tg-yw4l">181.0%, 55.2%  </td> </tr>
                         <tr><td class="tg-yw4l">Karma  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">21.8904sec </td> <td class="tg-yw4l">3654568.8712nums/sec </td> <td class="tg-yw4l">43.4%, 229.9%  </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">12.1877sec </td> <td class="tg-yw4l">6564009.9274nums/sec </td> <td class="tg-yw4l">24.2%, 413.0%  </td> </tr>
                         <tr><td class="tg-yw4l">atoi   </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">17.6615sec </td> <td class="tg-yw4l">5010896.5768nums/sec </td> <td class="tg-yw4l">100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">191.9446sec</td> <td class="tg-yw4l">461070.5357nums/sec  </td> <td class="tg-yw4l">1086.7%, 9.2%  </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">6.2808sec  </td> <td class="tg-yw4l">14090561.7119nums/sec</td> <td class="tg-yw4l">35.5%, 281.1%  </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">6.1552sec  </td> <td class="tg-yw4l">14378086.8208nums/sec</td> <td class="tg-yw4l">34.8%, 286.9%  </td> </tr>
                         <tr><td class="tg-yw4l">atof   </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">21.4865sec </td> <td class="tg-yw4l">1426474.1027nums/sec </td> <td class="tg-yw4l">100.0%, 100.0% </td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">139.8166sec</td> <td class="tg-yw4l">219215.7409nums/sec  </td> <td class="tg-yw4l">650.7%, 15.3%  </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">11.3916sec </td> <td class="tg-yw4l">2690567.9223nums/sec </td> <td class="tg-yw4l">53.0%, 188.6%  </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">6.4396sec  </td> <td class="tg-yw4l">4759608.7027nums/sec </td> <td class="tg-yw4l">29.9%, 333.6%  </td> </tr>
                       </tbody></table>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_gcc4_atom_chart.png" alt="C++ String Toolkit Library GCC v4 Atom N450 Chart - Copyright Arash Partow" border="0">
                       </p>


                       <h4 align="left">Scenario 6 - GCC 4.5 (O3, PGO) Intel Xeon E5540</h4>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-804w{font-family:Arial, Helvetica, sans-serif !important;;text-align:center;vertical-align:top}
                       .tg .tg-hgcj{font-weight:bold;text-align:center}
                       .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr>
                           <th class="tg-hgcj">Source</th>
                           <th class="tg-hgcj">Test</th>
                           <th class="tg-amwm">Size</th>
                           <th class="tg-amwm">Time(sec)</th>
                           <th class="tg-amwm">Rate</th>
                           <th class="tg-amwm">% from Baseline</th>
                         </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l"> 7.5657sec</td> <td class="tg-yw4l"> 3172216.8787tks/sec </td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-031e">StrTk  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l">2.7379sec </td> <td class="tg-yw4l">8765832.8290tks/sec  </td> <td class="tg-yw4l">36.1%, 276.3% </td> </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">3.0706sec </td> <td class="tg-yw4l">3126386.1126tks/sec  </td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">1.1279sec </td> <td class="tg-yw4l">8511136.2899tks/sec  </td> <td class="tg-yw4l">36.7%, 272.2% </td> </tr>
                         <tr><td class="tg-yw4l">sprintf</td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">10.9012sec</td> <td class="tg-yw4l">7338642.9638nums/sec </td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">12.3317sec</td> <td class="tg-yw4l">6487328.7872nums/sec </td> <td class="tg-yw4l">113.1%, 88.3% </td> </tr>
                         <tr><td class="tg-yw4l">Karma  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">3.7202sec </td> <td class="tg-yw4l">21504260.6660nums/sec</td> <td class="tg-yw4l">34.1%, 293.0% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">2.5183sec </td> <td class="tg-yw4l">31768042.4612nums/sec</td> <td class="tg-yw4l">23.1%, 432.8% </td> </tr>
                         <tr><td class="tg-yw4l">atoi   </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">4.0087sec </td> <td class="tg-yw4l">22077037.6357nums/sec</td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">30.3659sec</td> <td class="tg-yw4l">2914454.4393nums/sec </td> <td class="tg-yw4l">757.4%, 13.2% </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">1.7976sec </td> <td class="tg-yw4l">49231871.5454nums/sec</td> <td class="tg-yw4l">43.3%, 223.0% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">1.7384sec </td> <td class="tg-yw4l">50908881.7303nums/sec</td> <td class="tg-yw4l">43.3%, 230.5% </td> </tr>
                         <tr><td class="tg-yw4l">atof   </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">5.2118sec </td> <td class="tg-yw4l">5880843.9328nums/sec </td> <td class="tg-yw4l">100.0%, 100.0%</td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">21.5546sec</td> <td class="tg-yw4l">1421966.9538nums/sec </td> <td class="tg-yw4l">413.5%, 24.1% </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">3.2149sec </td> <td class="tg-yw4l">9533840.3118nums/sec </td> <td class="tg-yw4l">61.6%, 162.1% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">1.3929sec </td> <td class="tg-yw4l">22003661.2944nums/sec</td> <td class="tg-yw4l">26.7%, 374.1% </td> </tr>
                       </tbody></table>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_gcc4_xeon_chart.png" alt="C++ String Toolkit Library GCC v4 Intel Xeon E5540 Chart - Copyright Arash Partow" border="0">
                       </p>

                       <h4 align="left">Scenario 7 - GCC 4.5 (O3, PGO) Intel Xeon X5650</h4>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-804w{font-family:Arial, Helvetica, sans-serif !important;;text-align:center;vertical-align:top}
                       .tg .tg-hgcj{font-weight:bold;text-align:center}
                       .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr>
                           <th class="tg-hgcj">Source</th>
                           <th class="tg-hgcj">Test</th>
                           <th class="tg-amwm">Size</th>
                           <th class="tg-amwm">Time(sec)</th>
                           <th class="tg-amwm">Rate</th>
                           <th class="tg-amwm">% from Baseline</th>
                         </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l"> 4.1944sec</td> <td class="tg-yw4l"> 5721901.2924tks/sec </td> <td class="tg-yw4l">100.00%, 100.00% </td> </tr>
                         <tr><td class="tg-031e">StrTk  </td> <td class="tg-031e">Tokenizer        </td> <td class="tg-804w">24000000</td>    <td class="tg-yw4l">2.5087sec </td> <td class="tg-yw4l">9566860.3956tks/sec  </td> <td class="tg-yw4l">59.81%, 167.19%  </td> </tr>
                         <tr><td class="tg-031e">Boost  </td> <td class="tg-031e">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">2.9104sec </td> <td class="tg-yw4l">3298520.2014tks/sec  </td> <td class="tg-yw4l">100.00%, 100.00% </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Split            </td> <td class="tg-804w"> 9600000</td>    <td class="tg-yw4l">1.1105sec </td> <td class="tg-yw4l">8644949.2334tks/sec  </td> <td class="tg-yw4l">38.15%, 262.08%  </td> </tr>
                         <tr><td class="tg-yw4l">sprintf</td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">9.7148sec </td> <td class="tg-yw4l">8234840.3537nums/sec </td> <td class="tg-yw4l">100.00%, 100.00% </td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">11.5726sec</td> <td class="tg-yw4l">6912860.7120nums/sec </td> <td class="tg-yw4l">119.12%, 83.94%  </td> </tr>
                         <tr><td class="tg-yw4l">Karma  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">4.0832sec </td> <td class="tg-yw4l">19592620.4395nums/sec</td> <td class="tg-yw4l">42.03%, 237.92%  </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">Integer To String</td> <td class="tg-804w">80000000</td>    <td class="tg-yw4l">2.2204sec </td> <td class="tg-yw4l">36029641.5861nums/sec</td> <td class="tg-yw4l">22.85%, 437.52%  </td> </tr>
                         <tr><td class="tg-yw4l">atoi   </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">3.1028sec </td> <td class="tg-yw4l">28522836.1561nums/sec</td> <td class="tg-yw4l">100.00%, 100.00% </td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">6.1270sec </td> <td class="tg-yw4l">14444145.2249nums/sec</td> <td class="tg-yw4l">197.46%, 50.64%  </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">1.5313sec </td> <td class="tg-yw4l">57794031.2153nums/sec</td> <td class="tg-yw4l">49.35%, 202.62%  </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Integer</td> <td class="tg-804w">88500000</td>    <td class="tg-yw4l">1.4409sec </td> <td class="tg-yw4l">61417814.6362nums/sec</td> <td class="tg-yw4l">46.43%, 215.32%  </td> </tr>
                         <tr><td class="tg-yw4l">atof   </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">6.1342sec </td> <td class="tg-yw4l">6990292.6549nums/sec </td> <td class="tg-yw4l">100.00%, 100.00% </td> </tr>
                         <tr><td class="tg-yw4l">Boost  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">28.9461sec</td> <td class="tg-yw4l">1481374.9232nums/sec </td> <td class="tg-yw4l">772.37%, 21.19%  </td> </tr>
                         <tr><td class="tg-yw4l">Qi     </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">3.6549sec </td> <td class="tg-yw4l">11732137.3557nums/sec</td> <td class="tg-yw4l">59.58%, 167.83%  </td> </tr>
                         <tr><td class="tg-yw4l">StrTk  </td> <td class="tg-yw4l">String To Double </td> <td class="tg-804w">30650000</td>    <td class="tg-yw4l">1.3860sec </td> <td class="tg-yw4l">30937683.0792nums/sec</td> <td class="tg-yw4l">22.59%, 442.58%  </td> </tr>
                       </tbody></table>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_gcc4_xeonII_chart.png" alt="C++ String Toolkit Library GCC v4 Intel Xeon X5650 Chart - Copyright Arash Partow" border="0">
                       </p>

                       <p align="left">
                        <b>Note 1:</b> The tests are compiled with specific optimisation flags to
                        produce the best possible results for the respective compilers and architectures.
                        Furthermore the tests are run natively <em>(no virtualizations were used)</em>
                        on an almost completely idle machine so as to reduce interference from background
                        processes. The Boost version used was 1.55. Furthermore the standard libraries
                        including libc were rebuilt for the linux system based tests, using architecture
                        specific flags and optimizations. The following is a table mapping the scenarios
                        to their respective architectures:
                       </p>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-s6z2{text-align:center}
                       .tg .tg-hgcj{font-weight:bold;text-align:center}
                       </style>
                       <table class="tg">
                         <tbody><tr>
                           <th class="tg-hgcj">Scenario</th>
                           <th class="tg-hgcj">Architecture</th>
                         </tr>
                         <tr> <td class="tg-s6z2"><br>0</td> <td class="tg-031e">ThinkPad W510<br>(64-Bit Intel Quad Core Extreme i7-920XM 2.0GHz, 16GB RAM, Windows 7)</td>  </tr>
                         <tr> <td class="tg-s6z2">  1-3</td> <td class="tg-031e">ThinkPad x61<br>(32-Bit Intel Core 2 Duo 2.4GHz, 2GB RAM, Windows 7)                  </td>  </tr>
                         <tr> <td class="tg-s6z2"><br>4</td> <td class="tg-031e">ThinkPad x61<br>(32-Bit Intel Core 2 Duo 2.4GHz, 2GB RAM, Mint 15)                    </td>  </tr>
                         <tr> <td class="tg-s6z2"><br>5</td> <td class="tg-031e">Acer Aspire One<br>(32-Bit Intel Atom N450 1.6Ghz, 1GB RAM, Mint 15)                  </td>  </tr>
                         <tr> <td class="tg-s6z2"><br>6</td> <td class="tg-031e">HP Proliant DL380G6<br>(64-Bit Intel Xeon E5540 2.5GHz, 8GB RAM, Mint 15)             </td>  </tr>
                         <tr> <td class="tg-s6z2"><br>7</td> <td class="tg-031e">Custom box<br>(64-Bit Intel Xeon X5650 2.66GHz, 32GB RAM, Mint 15)                    </td>  </tr>
                       </tbody></table>

                       <p align="left">
                        <b>Note 2:</b> The percentages in the final column represent the
                        percentage of the current row versus the baseline in total running
                        time and rate respectively. For the first percentage the lower the
                        value the better and for the second percentage the higher the value
                        the better. The baseline used for a specific combination of tests is
                        defined in the following table:
                       </p>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       </style>
                       <table class="tg">
                         <tbody><tr> <th class="tg-031e">Test Combination</th> <th class="tg-031e">Baseline</th> </tr>
                         <tr> <td class="tg-031e">Boost, StrTk                    </td> <td class="tg-031e">Boost     </td> </tr>
                         <tr> <td class="tg-031e">Boost, StdLib/STL, Spirit, StrTk</td> <td class="tg-031e">StdLib/STL</td> </tr>
                         <tr> <td class="tg-031e">StdLib/STL, Spirit, StrTk       </td> <td class="tg-031e">StdLib/STL</td> </tr>
                       </tbody></table>

                       <p align="left">
                        <b>Note 3:</b> The test sizes are set such that no single run will
                        result in a running time less than one second. This is done so as to
                        ensure that runs-per-second results are not deemed to have been
                        projected. In the future these sizes may need to be revisited once
                        3.5+GHz CPU speeds become more commonplace. Furthermore the charts
                        represent the rate of operation over a one second interval - In short,
                        the larger the rate the better.<br><br>

                        <b>Note 4:</b> The binaries used for the above performance tests can
                        be downloaded from here<br><br>

                        <b>Note 5:</b> It would be great to have comparisons for other
                        architectures. If you can provide access to shell accounts with GCC
                        4.5+ or Clang/LLVM 2.0+ for the following architectures: UltraSPARC T2
                        Plus, SPARC64 VII, POWER6/7, please feel free to get in contact.
                       </p>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="AFinalDigression">A Final Digression - Fast Integer To String Conversion</a></h3>
                       <p align="left">
                        The task of converting an integer to a std::string is quite common and
                        rather trivial. It is mainly used in serialisations, such as printing
                        to stdout or a file et al. The above benchmarks do include timings for
                        int to std::string conversions, however let's see if there's more that
                        can be done.<br><br>

                        The following takes this very simple task to the next level. Based on
                        a series solutions found on StackOverflow and elsewhere, the following
                        benchmark has been derived. Its objective is simple: Determine the
                        fastest integer to std::string conversion routine, written entirely in
                        conforming C++. The results are as follows:
                       </p>

                       <style type="text/css">
                       .tg  {border-collapse:collapse;border-spacing:0;border-color:#999;margin:0px auto;}
                       .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#444;background-color:#F7FDFA;}
                       .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#999;color:#fff;background-color:#26ADE4;}
                       .tg .tg-hgcj{font-weight:bold;text-align:center}
                       .tg .tg-yw4l{vertical-align:top}
                       </style>
                       <table class="tg">
                         <tbody><tr>
                           <th class="tg-hgcj">Method</th>
                           <th class="tg-hgcj">Rate (per/sec)</th>
                         </tr>
                         <tr> <td class="tg-031e">sprintf  </td> <td class="tg-031e">3903490    </td>  </tr>
                         <tr> <td class="tg-031e">karma    </td> <td class="tg-031e">17305869   </td>  </tr>
                         <tr> <td class="tg-031e">zverovich</td> <td class="tg-031e">19036262   </td>  </tr>
                         <tr> <td class="tg-yw4l">voigt    </td> <td class="tg-yw4l">21489702   </td>  </tr>
                         <tr> <td class="tg-yw4l">so       </td> <td class="tg-yw4l">32617186   </td>  </tr>
                         <tr> <td class="tg-yw4l">timo     </td> <td class="tg-yw4l">46211794   </td>  </tr>
                         <tr> <td class="tg-yw4l">hopman   </td> <td class="tg-yw4l">52160759   </td>  </tr>
                         <tr> <td class="tg-yw4l">strtk    </td> <td class="tg-yw4l">52650806   </td>  </tr>
                         <tr> <td class="tg-yw4l">jiaendu  </td> <td class="tg-yw4l">60955167   </td>  </tr>
                       </tbody></table>

                       <p align="center">
                        <img src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/strtk_fast_into_to_string_convert_chart.png" alt="C++ String Toolkit Library Fast Integer To String Convert Chart - Copyright Arash Partow" border="0">
                       </p>

                       <p align="left">
                        <a href="http://www.partow.net/programming/strtk/data/fast_int_to_string_conversion.zip"><b>Download Integer To String Conversion Benchmark</b></a><br><br>

                        <b>Note:</b> The following are details and also some points to
                        consider with regards to the benchmark presented above:
                       </p>

                       <ul style="text-align: left">
                       <li>
                        A total of nine conversion routines are employed, of varying
                        complexities, ranging from simple divide/mod and loop to elaborate
                        single pass bit-twiddle LUT based strategies.
                       </li>

                       <li>
                        A wide range of values within the int space are used. They consist of
                        sets of small and large random values, values near to and including
                        min/max of int and all values from -20000000 to +20000000. Furthermore
                        the various values are interleaved amoungst each other during the main
                        loop for each conversion routine.
                       </li>

                       <li>
                        Prior to the benchmark beginning, a simple sanity check is run over
                        all the conversion routines to make sure each routine functions
                        correctly.
                       </li>

                       <li>
                        Before each conversion routine's benchmark begins, an attempt is made
                        to flush the I/D caches. This is done so as to avoid the previous
                        conversion routine's execution profile affecting the next routine.
                       </li>

                       <li>
                        It should be noted that the results presented were derived from
                        running the benchmark upon a processor which has a large L1/L2 cache.
                        This is important because when run on processors that have smaller
                        caches or none at all, the rankings change quite a bit. In fact the
                        simple div/mod and loop strategies will tend to out do most of the LUT
                        based strategies under certain architectural conditions. This point is
                        applicable not only to processes running atop of embedded and low
                        power processors but also to processes running within virtualized
                        environments.
                       </li>

                       <li>
                        The system details are: Intel Xeon W3680 3.3GHz, kernel 3.11, GCC 4.8
                        O2 compiled with PGO.
                       </li>

                       <li>
                        The conversion implementations found in boost::lexical_cast,
                        <a href="https://code.google.com/p/stringencoders/wiki/NumToA">NumToA</a>
                        and <a href="https://github.com/facebook/folly">Folly</a>
                        were found to be exceedingly lacking when it came to performance
                        and were hence left out.
                       </li>
                       </ul>

                       <br><hr style="color:#3366FF"><hr style="color:#3366FF">

                       <h3 align="left"><a name="StrTkLibraryDependency">StrTk Library Dependency</a></h3>
                       <p align="left">
                        StrTk makes use of the Boost library for its <b>boost::lexical_cast</b>
                        routine for types other than PODs, and its TR1 compliant Random and
                        Regex libraries. These dependencies are not compulsory and can be
                        easily removed simply by defining the preprocessor:
                        <b>strtk_no_tr1_or_boost</b>. That said Boost is an integral part of modern
                        C++ programming, and having it around is as beneficial as having
                        access to the STL, hence it is recommended that it be installed. For
                        Visual Studio users, BoostPro provides a free and easy to use
                        installer for the latest Boost libraries that can be obtained from
                        Here. For Linux users, mainstream distributions such as Ubuntu and
                        Red-Hat(Fedora) provide easy installation of the Boost libraries via
                        their respective package management systems. For more information
                        please consult the readme.txt found in the StrTk distribution.
                       </p>

                       <br><br>

                       <!-- Start of StatCounter Code -->
                       <script type="text/javascript">
                       var sc_project=5179476;
                       var sc_invisible=1;
                       var sc_partition=48;
                       var sc_click_stat=1;
                       var sc_security="2723e021";
                       </script>
                       <script type="text/javascript" src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/counter.js.&#19979;&#36733;"></script><noscript><div class="statcounter"><a title="wordpress counter" href="http://www.statcounter.com/wordpress.org/" target="_blank"><img class="statcounter" src="http://c.statcounter.com/5179476/0/2723e021/1/" alt="wordpress counter" ></a></div></noscript>
                       <!-- End of StatCounter Code -->

                       <script src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/urchin.js.&#19979;&#36733;" type="text/javascript">
                       </script>
                       <script type="text/javascript">
                       _uacct = "UA-2440650-12";
                       urchinTracker();
                       </script>

                      </td>
                    </tr>
                  </tbody>
                </table>
                <br>
              </td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td class="pos_bottom" height="20" colspan="2" valign="middle">
        <div class="copyrightbox">© Arash Partow. All Rights Reserved.</div>
      </td>
    </tr>
  </tbody>
</table>
</div>


<script type="text/javascript" src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/296069.js.&#19979;&#36733;"></script><script type="text/javascript" src="./___ C++ String Toolkit Library (StrTk) - By Arash Partow __._files/296069.js.&#19979;&#36733;"></script></body></html>